teStreamBox
01:49:39 ICFP-2022 Ljubljana. 
01:51:14 Welcome to the event, we will begin shortly, and captioning will be provide. 
01:51:23 Welcome to the event. We will begin shortly, and captioning will be provided. 
01:51:30 Test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test. 
01:51:41 [Audio connected -- ] 
01:52:13 Welcome to the event. We will begin shortly, and captioning will be provided. 
01:52:30 Test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test test. . 
01:55:40 >> Good morning, everyone. 
01:55:44 Look, I'll wave and the picture will change. 
01:55:46 [Laughter] 
01:55:53 There is a magic incantation you can say. It's not working. 
01:56:02 Thank you. 
01:56:02 Welcome! Welcome to ICFP. 
01:56:07 [Applause] 
01:56:15 In case you don't know, and I'm not wearing my name tag, always forget it on the second day. 
01:56:24 Andre Bauer the general change, the last ICFP I'm organizing. 
01:56:30 [Laughter] >> but every morning you're going to hear a short note from me about the social events taking place on that day. 
01:56:36 So today we have one of the main social events, which is the reception, which is paired with the student research competition posters and taking place at the castle. Before that we have guided tour of Ljubljana and trying to count the number of people who are going to come and have limited number of spaces, so you have to please sign up, and all the info about the events is in the schedule, click on the scheduled event, and you will get detailed info on what to do. Okay? 
01:57:08 And just one other point... I'll be short. If you are a speaker please submit your slides prior to the session, at the tech desk where is says submit slides. 
01:57:25 Trying to have as many people use slides as possible, because it's now clear on the venue, it's no joke. Switching laptops is a joke, we should minimize that. If you are using a laptop because of a live demo, you should appear here 20 minutes prior to the session. So that you can test things, and very importantly all the speakers should appear 10 minutes before the session, because we're going to put you in the first row, so that we can quickly change, and we will put mics on new and so onon. So that's all I have to say, please enjoy the conference, and Stephanie first session chair, the word is yours. 
01:58:10 >> Thank you. [Applause]. 
01:58:20 Stephanie Weirich: So it's my very great pleasure to introduce our first invited speaker for ICFP, our own Nate Foster who will be telling us about programmable networks, if you have been around ICFP, you have probably met Nate before, if this is your first time at ICFP you are in for a real treat, and super thrilled I get to introduce you to him and his work. I have known Nate for a long time, started at Penn as Ph.D. student in 2003 and worked on his dissertation with my colleague Benjamin Pierce, and worked on lenses and developed as part of the work boomerang programming language. But even more important to me was, I was starting at the very same time as a Junior Assistant Professor at Penn and Nate was a really important part building up the culture of Penn's PL club of our programming language research group, and together in those early years we did a lot of really wonderful things, hosting the ICFP programming contest that Nate was important part of or issuing the PM talent. So that was just a fantastic time, and I was really glad to have Nate. Nate finished his PhD at Penn 2009 Princeton started a postdoc with David Walker and they're with David Walker and denatured and many others. He began his work on programmable networks and he's gonna tell us a lot about that work today. What I want to spend just a minute right now, telling you how much I love that work, and how much it really embodies what I love about ICFP. 
02:00:20 Some of my favorite work at ICFP is work that takes beautiful mathematical idea and is applies them to real programming problems. 
02:00:29 And of course this feels great, because it validates everything, and tell each other. But it doesn't come for free. Nate has put in so much effort in terms of forging interdisciplinary connections, and reaching out othe network community, and reaching out to industry partners and also devoting many countless hours and thankless hours for the open source communities, for the programming language, and to actually show and demonstrate these ideas do makes sense. 
02:01:08 And as a result -- I mean it's paid off, his work had tremendous impact, not just here at ICFP but also in the networking community. 
02:01:21 I do want to call out, two of his ICFP papers that have been recognized. Last year, his phonetic paper that appeared in ICFP 2011 was awarded the most influential paper award. So every year ICFP picks a paper from 10 years back, so 2021, the paper selected was Nate's paper. 
02:01:48 That frenetic paper was one of the first ones that built on his work at Princeton, and continued to develop as a professor at Cornell and then 2015 his work fast compiler for Netcat. That paper was selected by SIGPLAN as research highlight out all of the paper that appear in SIGPLAN conferences for the year, one specifically called out ASCII research results for that year. 
02:02:25 He's also been honoured by the networking communities as well. 
02:02:31 So in addition to sending his best work to ICFP he also has won many paper awards at networking conferences such as NSDI, CoNEXT. And with a SIGCOMM rising star award. It's clear the networking community truly values him as a full member, and working very close with them for the past -- I don't know how many years. So we need more researchers like Nate that can really not just have these -- take these great mathematical ideas, but really push them through and get them out to the people who need to know about them. So with that, I'm going to close so that we can hear more just about how he did it, and hear more details about programmable networks. 
02:03:25 Thank you. 
02:03:25 [Applause] 
02:03:35 >> NATE FOSTER: Thank you Stephanie for the far too kind and generous introduction, and thank you all for having me, really wonderful to be back at conferences and in Slovenia. I was looking at my history, I first came to Slovenia in 2003, and first ICFP in 2004. And really good to be back in familiar places. Thanks enough for inviting me the great arrangements and thanks for all the student volunteers for making conferences like this possible. So I'm going to start with kind of a big question. 
02:04:11 Like, what's the most important problem in computer science right now. If you go ask your colleagues and you know you might hear answers like maybe quantum computing or P versus NP or aachievering artificial general intelligence. But if you go back 50 years, the central problem in computer science was programming and programming languages right there was conferences, this is a picture of the famous NATO software engineering conference. Not so diverse, but see people like D... and many others. And the problem they were looking at was how to write software at all. 
02:04:43 And there is a famous quote from Dijkstra: I won't read it. But essentially says, way back when computers were small and wimpy, we thought programming was hard because, well, we had to write this low level code that was very clever because you know computers are very good, but I can hear just got fast, and we discovered it was the smallest of the computers that was the problem, it was just we don't understand the science of programming. And this set off most of the work in our field developing ideas like structured programming and type system and is program logics, and whole methodology how to write software. Amazing things have been achieved. If you think about modern software -- of course still a challenge to write good software. But a lot of the problems struggling with 50 years ago we made great progress on. If you step back the nature of big systems have changed. Nowadays a lot of systems are developed on the cloud and run on phones, no longer in the era running a program that runs sequentially on one machine. A lot of important software runs in the large planetary scale to root systems. With the end of Moore's law. We're seeing the rise of accelerators, things like GPUs and TPUs And increasingly, you know there's more computation and these specialized accelerators and there aren't CPUs and large systems. We still don't really know the program then. And security is another just full stop. You look in the head lineses you see situation where large data sets of sensitive data compromised and stolen by attackers and still don't have a really good methodology for building secure systems. So I would argue the task that the folks at NATO conference were concerned with, how do we raise level of abstraction and build science of programming, we still need to solve those problems today just that the underlying computers have changed. And one common things to all the modern systems is that networks really play a central role. The only way to have plan tear scale distributed system, that talks to dozens of machines and hundreds of machines in the cloud, and communicates data to your phone is because there's really fast networks that connect them. The only way we can have accelerators that are coordinated with the CPU to do big computations is again because of some kind of network locally on a system. But by in LARNL, the way we program networks -- if we can program them at all. Is writing machine code, we don't really have high level abstractions. And we don't have compilers, sitting there mucking with the bits at very low level of abstraction. 
02:07:29 This is more than just a failure to be creative. For many decades the technology the networking industry has given us has been very closed and fixed. 
02:07:40 And I would characterize this as being a sort of bottom up approach to networking. By "bottom up" the network tells you what you can do and you have to write the program given those capabilities. What do I mean? 
02:07:57 Things like you can send a packet maybe between two machines, that's not something can you define yourself, but have to rely on standard bodies like the IDF give you, and have have to rely on distributed protocols, say PGP, which is setting up routes across the network, you have to worry about what vendors like Cisco or Juniper these big network hardware vendor they tell you they can do. And so, if you're a system owner and you're trying to build some big network system, you may have an idea about the kind of network you'd like to support your application, but it's very hard to take that idea and realize it in a practical setting, instead you end up mucking up with all these low level notioneds addresses VLANs, maybe you're tweaking link weights to get the past you want to the network, it's very indirect, very brittle and limited. So the place we like to go, and place we are going is basically flipping this error around. So the program that runs on the laptop I don't start thinking about the kind of disk and memory I have. And organize my data structures to fit that. I tend to start with a programming language like Haskell and wries down the types I want, and compile those down from memory. And same way I want to take the network functionality I want and able to specify in some reasonably high level way and compile down to the infrastructure. This is becoming possible. Several key ingredients, one is the underlying hardware that we use to build network devices like routers has become more programmable. So there's the possibility to customize it to suit particular needs. There's. 
02:09:39 Early stages I argue family of domain specific languages and domain specific abstractions for describing network functionality. And then there's compilers verification tools and so on, but take all this software, and figure out a map it down to the underlying system. I just want to give you a taste of killer applications driving this so far. I want to be clear this isn't the limit of what we can do. But the lowest hanging fruit, or most pressing needs I've driven networking people to think about generalizing networks to become more programmable. The first killer ap, cloud virtualization. 
02:10:19 The idea here, big cloud company and want to get more customers, the customers probably have existing deployment in their own office, or site, and you would like to be able to take that deployment and move it to the cloud. 
02:10:34 And it's pretty easy to take a java program or C programmer and Haskell program and move to cloud VM, acts just like a server you have locally. But there is all this other stuff attached to such an applications including things like specific IP addresses and specific network topologies, and quickly the companies realized if you can build a capability and take a network someone had locally, and emulate it in the cloud, giving the same structure, and same addresses and everything else, and you can ease this transition path to the cloud, so a bunch of work, maybe about 10 years ago, using programmable networks to achieve this kind of network virtualization. Another killer app was traffic engineering, this is old problem in networking and really the goal here is to take a set of network paths that somehow serve all the traffic while minimizing cost and latency and is maximizing robustness And historically, this is done through distributed protocols, and very clever ways of encoding optimization into those treated protocols, but some of the really bigcloud companies again started to have infrastructure that was sufficiently large, that they wanted to actually use mathematical optimization to come up with the perfect solution. 
02:12:02 solution., so having a platform where you can take a constraint sol VER, and come up with the exact paths you want and push those down into the network actually saved them quite a bit of money and let them run their networks much more efficiently, another place there has been quite a renaissance of work explaining variable networks is monitoring. Historically if you want to understand what the network is doing, think of analog of debugger, you have very rudimentariry tools, you can use command line like ping or trace route, or maybe you have some boxes that can sample traffic and then give you reports of, you know, what packets were going across certain links, and from that you can try to piece together what's going on. Well, with a programmable network ou can actually build a proper debugger, you can have every packet, keep track of a log of what happened. Maybe telling you what paths, it took, how much cueing experienced, maybe causal relationships between different flows. And so this can give you a very fine grained picture of what's going on the network, and that can inform other network operations. And then lastly, there's been some interest I would say this is a little more preliminary in what you might call in network computing. And this is really rethinking the fundamental contract between sort of end host applications and the network. In the internet, the basic contract is the internet gives you best effort packet delivery and nothing else. But it's possible, and in some cases it may make sense to build richer services and have the network do cashing of commonly accessed data items, and have it implement parts of or all of consensus coordination protocols and helping multiple machine agree on state of system. You could have the network run to failure detector, and so if you have the ability to program the network you can do, you know, some or all of these things, and there's a community that starting to explore this. So that's a taste of where the networking field is going. And some of the motivating examples driving them to do that. And want to say about the system architecture level now this change in a little more detail. 
02:14:12 So, let me define a few terms, probably most of you I hope have taken an under grad OS or networking class, and might remember -- actually when I interviewed for postdoc being PL person, my interview question was do you know the different between control plane and data plane, yeah, I remember that and that was it. This is fundamental division of labour in a network. Yeah, Steve. Oh, the slides are not advancing, thanks for noticing. 
02:14:47 So the slides advanced on my laptop, not quite sure how to sync with the room system. 
02:14:56 Hmm... clearly a network failure. 
02:14:58 [Laughter] 
02:15:06 Andre? 
02:15:06 What was the magic move, wave my hand or something? 
02:15:11 Hmm I'm tempted to try to exit full screen, but it's in Slovenia and worried I won't be able to get back in. [Laughter] 
02:16:04 
02:16:04 
02:16:05 
02:16:05 
02:16:08 
02:16:08 
02:16:56 >> NATE FOSTER: Great... okay. 
02:16:59 Still a bit of a lag, but it seems... no... 
02:17:19 Clear 
02:17:27 
02:17:28 
02:17:30 
02:17:32 . 
02:18:11 >> NATE FOSTER: Okay. Let's see... one more check. Seem to be back in sync. Great, I want to tell you a little bit about the underlying architectural changes I'm calling deep programmability, that have made this way of thinking about networks and more flexible and programmable possible. So back to the undergrad networking one of the main... oh, no, I'm going to try to go slowly, so I don't lose my whole time. 
02:18:47 Though, would be very confusing if the slides are a minute behind what I'm saying. 
02:19:01 [Laughter] 
02:19:02 
02:19:02 
02:19:04 
02:19:04 
02:19:08 >> NATE FOSTER: Okay. I'll just keep trying until we figure it out. So one of the main divisions of labour in a network that goes back to pretty early network devices and net work architectures is the division between the control plane and data plane, control plane is part of network responsible for running graph algorithms and computing paths and spanning trees, and in some cases enforcing certain kinds of policies and the data plane is the thing that actually forwards packets. So you can think of the control plane, it's really, you know, a general purpose programprogram, and running on CPU, and data plane running on specialized hardware, and it's got some kind of pipeline that can forward packets at very high data rates. 
02:19:56 So this is sort of the at that timus quo that leads, to bottom up design network equipment vendors sell you sort of both of these pieces together the pieces implement standard protocols like IP and BGP and so on, and you it put into the network and as advertised but short of configuring it it's hard to change it's behavior. 
02:20:59 [Off mic]. 
02:21:05 [Laughter]. 
02:21:06 >> NATE FOSTER: It's tempting. 
02:21:09 [Off mic comment] 
02:21:11 >> NATE FOSTER: Wonderful. Yes, I'll keep trying, let me know if I should try and plug in my own laptop, I think the issue is with the room AV system not the display here, let me know if something I should do. First piece was to realize there is no deep reasons these need to go together. , right, network devices have these two roles, the control plane the data plane but they can really be separated. And once you've done that.... 
02:21:55 >> NATE FOSTER: Not quite sure what to do... [off-mic comment]. 
02:22:00 [Laughter] 
02:22:03 >> NATE FOSTER: Very quickly get into the PL material and harder to explain audibleably. And serious question for Andre or room people, something else I should do. Very hard to give a talk with 20 second pause between every animation. I'll just keep going. So once we separate these two, there is... 
02:22:28 no need to have a single control plane attached to every single data plane, and can think about having one control plane managing many data planes, and this... initially was called logical centralization. People said, we can just write centralized algorithms that manage a whole data center or a local network. There's a phrase that I prefer which is it allows you to sort of pick the right unit of abstraction for the control plane. Historically the control plane, always had to be a fully distributed algorithm,algorithm,but with this new kind of architecture, you can imagine having maybe a small number of control planes. Probably want several for fault tolerance, and scale, but don't need 1000 control plane instances for 1000 data plane so you could just have five. We probably want standard ways of communicating between the control plane and data plane, instead of having each vendor implement in some custom way opaque to the outside, we're going to define standard protocols and let anyone implement two sides of it. And then now the control plane doesn't need anything special. It can just be a server running in a rack. Nova Scotia we want to customize the control plane, maybe to implement a different kinds of routing policy, we no onger have to go change BGP or go talk to standards bodies, you can just write a different program running on that server. The last piece and really only happened say 5 or 6 years, the ability to also make the data plane programmable. Now instead of having to implement standard protocol IP or TCP or VLANS, you can actually define custom header formats and custom processing at the data plane level as well. So this term: 
02:24:20 Deep programmability, one we coined in position paper last year. The idea that instead of network infrastructure being fixed and telling you what it can do, truly the network infrastructure has become a fully programmable platform, and program top to bottom, from control plane and data plane, and really end to end, and take the path the packets are taking, and processing. And now think of network has another piece of broader distributed system you might be building, and customize the network behavior to best suit that system. 
02:24:57 So I want to shift now and talk a little bit how we might program this kind of system. 
02:25:02 And I want to tell you a little bit more how the data plane KWIESs workKWIESs -- devices work, We'll come back to this at the end of the talk. But essentially, all data plane devices whether it's a router or a switch or a gateway or firewall, they all have a very similar structure, which is they start by taking packet coming in. Packets are just bits, parse them, and pull out the things the headers might want to examine, and purpose deciding how to forward them, and then do lookups in some fast hardware tables that match on certain header and is maybe look at destination addresses and other pieces of data and do things like forward or drop those packets and after the decisions are made of course we have to deparse the packets back into the bits to send them out. 
02:25:55 So they can be more complicated than this, but the key thing I want you to notice the action of this device is in the middle, with this table, could be many tables, I'm going to pretend just one table, describing the behavior of the device, can be characterized in two phases. 
02:26:24 There's a match phase where we're taking the incoming packets all of them, and deciding how to split them up into different equivalence classes, and then there's the action phase where we can apply small sort of scripts are small procedures to the packets. 
02:26:33 I also want to tell you more about the control plane APIs, this is notional control plane API, but essentially need messages going in both directions to manage the network, we need the network to tell us about certain kind of event switches joining the network or ports coming up or down, and know about statistics, and we may need to know about packets that are in the network that haven't been handled by each device. And then the controller also needs a way to reconfigure the data plane so it has the ability to manipulate the table and is install, delete, and modify rules in the tables and inject packets in the data plane, for example for wants to discover links between two devices that might inject a special probe packet, and it can also request statistics. This is sort of the basics of how the control planes work. So if we want to program these things and apply the same ideas as were done in response to software crisis in the context of networks we want to somehow raise the level of abstraction, and let us think in terms of higher levels things than hardware notions. 
02:27:43 So the kind of built-in model the deep programmable architectures give you really tied to the capability of the underlying hardware, there are these tables and describe how to populate these entries, but limited to single device and have to worry about very low level questions, how do you encode the predicates you want to match on to some linear table or how to split up the processes across entire path to hop by hop actions. 
02:28:16 So probably don't have to convince you, but when I first started looking at this, as functional programmer and someone who thinks about semantics it was immediate obvious much better way to think about this is have domain specific program model and describe the behavior of the network in simple composable abstractions like maybe functions. 
02:28:39 So instead of worrying how they're implemented we can write little functional programs and these things will describe transformations that take in packets and spit out packets and wire them together in interesting ways. 
02:28:53 So let's just explore from first principles what such DSL for higher level functional abstraction for networks might look like. So I'm going to think about functions of this type, going to unpack, and set of packets as outputs. There'll be a set for reasons will become clear in a moment but just for now, you know, one of the things you might need to do is drop packets. So, at a minimum, we need to be able to produce some kind of optional value or the empty set, the common case will be the packets of course just get forwarded, one comes in one goes out, and think of packets as just really records. In general packets can have many different formats for the time being presend packets have one standard type, record with maybe headers encode source and destination addresses, and also throw in location of the packet, which devices it's at, and port it's on the device. As pseudo header that I can work with in the same way.And if you've seen talks on their work before, you might remember that we actually want to keep track of packet histories, I'm going to liv So, the first and most fundamental thing that a network needs to do is to forward packets. , so just to get going I have a primitive, that will let me forward packets, modifying this record. 
02:30:27 So I'm going to have a little primitive for assignment and I can assign the Port field, which will cause the packet on a single device o get forwarded from across the, across the device from one to the next, And even though I'm using assignment here, This is still describing some kind of function on packets. Right I'm modifying these headers or pseudo packet I'm not actually keeping state on the device. . 
02:30:49 Okay, so... now I want to take you through a bunch of other constructs we could have. 
02:30:56 Another component of this kind of language is we probably want to think not about behavior of individual devices and stitch them together and see what happens, we actually want to program whole paths, or the network as a whole. 
02:31:08 And so, we're going to allow ourselves to also program the links, and able to say, when should packets flow across a link from one device to another, and use the arrow notation that denotes program takes packet from switch A and moves them across to switch B. 
02:31:28 There is a lot of cases where we need to apply different policies to different kind of of packets, maybe packets for web traffic on one path, and packets for Zoom traffic to another path, so we want conditionals that can branch on different predicates evaluated against the packet, and then apply one program or another, depending on whether the predicate is satisfied. We also of course want the composition. So we'd like to take a program that describes, maybe forwarding through a part of the network, and another program, and we'd like to stitch those together. 
02:32:03 And there is many different types of that we want. But maybe the most fundamental is sequential composition. You know, doing one thing and then another. And lastly, we also want loops, and this is a little bit counterintuitive because usually networking people don't like having loops if you have a forwarding loop that's a bad situation, with packets cycling around forever and ever. But in many situations, it's useful to be able to describe at least iterated processing in a network. So think about taking maybe one step of processing anything Yeah, do that until packets leave the network. 
02:32:34 That's a very succinct way to describe how to achieve connectivity. 
02:32:39 So putting this all together. 
02:32:39 We. 
02:32:44 Arrive at a little DSL, where we have a set of predicates, simple Boolean predicates and evaluated over the fields in the record that encodes packets and little programming language, where the programs include identity program that does nothing, drop program that produces no packets as output, assignment, composition, and this link construct that forwards from one device to another. . 
02:33:15 And this is quite natural, and some of the early work we did on SDN languages looked like this. 
02:33:21 And little fly in the ointment which is it's actually impossible with the syntax I've shown you here to write a program that produces multiple every packet produces either zero or every program produces either zero or one packets. And so there's never the possibility of doing anything like broadcast or multicast. . So you could imagine adding a special primitive to do this. And in fact some of the early languages I worked on had such a primitive, maybe there is a primitive flood, and if a packet comes in flood will copy that packet N times, where N equals the number of other ports on the device and then it will forward one copy of the packet of each of those ports. And this is maybe a sensible thing to do, but there's a little puzzle is, sorry, font corrupted with the presentation, little puzzle is, you know what happens when with itself. 
02:34:24 So does that somehow produce n squared packets do we somehow deduplicate things. And I don't think these problems are insurmountable but it suggests that maybe, you know, there's something a little odd going on here. So there is a second take on this DSL, so this is one that we ended up with as being a little bit more natural, and essentially the idea is instead of throwing in big operations like flood that are sensible from operational perspective but a little bit clunky semantically, we're going to try and distill the operations down to simpler and more orthogonal primitives. In particular, we're going to add a union operator, which I'll write with a plus. 
02:35:07 Which duplicates packs, and then applies, one of two programs to each copy and using the senior operator we can encode flood fairly easily. If we know the number of Portland device. And we can apply similar streamlining to other operators. 
02:35:18 So instead of loops we can have iteration, instead of conditionals we can encode that with Union. And we can actually smash together bunch of other operating putting the logical predicates and an or we can conflate those with with sequential composition and union, and derive the trivial programs identity and drop, as trivialial filters true and false. And end up with very minimal listic, that encodes everything we seen in simpler and more orthogonal way. If you haven't seen this before, neat thing is we can align DSL with system called KAT. Combination of a language of Boolean predicates and the language of regular expressions. Dexter was interested in this because he was interested in having nice algebraic models of imperative programming, and we take the same foundation and add this interpretation in terms of packet processing functions and some additional primitives like forwarding on the link, or modifying fields in the header, and weget a system called NetKAT. 
02:36:34 The thing I want you to take away from this if you didn't follow the details is. 
02:36:34 First, you can sort of apply the toolkit of the icfp community. 
02:36:34 Going in with a mindset and designing DSLs where your guide and the design both by the operational considerations in the domain but also by trying to do things in a clean semantic way. Even better if you align with existing mathematical framework, that framework can give you guidance, and tell you what kind of primitives to have and how to interpret certain operations in the case of NetKat. The KAT framework gave us guidance in deciding how to resolve tricky issues like this question of how to do flood, as well as a ready made verification toolkit. So this NetKAT language, I'm not going to show all the details, but studied semantics in different ways. We have additional semantics that looks much like the functional interpretation I was showing you in pictures. We also have an axiomatic semantics. Essentially from NetKat itself. As being a kind of automata. And that's very useful in building implementations. And these three things. The three semantics, all fit together with ice they're telling you that they agree and capture the same thing. 
02:37:51 I want to show you just an application of the language, and how some of the pieces in the semantics can be put to work to solve real problems, and this goes back to the first killer app I showed you for deep programmability, which is virtualization. So I want you to imagine the physical network is thing in gray here. Kind of straightforward tree topology with switches numbered 1-7. And ports in small numbers, you don't have to follow the small details, but curious, those ports are the connect and switches. 
02:38:33 And imagine that I want to take a virtual network. So I want to pretend that this network just has a single device. And the device has outgoing ports that correspond to low ends of the tree. 
02:38:40 So you can imagine a customer say in a cloud network would have one switch they have in their office and want to move this thing to the collude, but the cloud provider will run the network in the tree topology. 
02:38:54 So the task we want to solve is programs written against the virtuevirtual network, here is program in yellow just implements forwarding between the 4 ports and virtual switch as followed by destination addresses and want to realize that in the physical network. 
02:39:12 And so, using our implementation of DSL we can actually do this. So here is little demo of compiler running on that exact program showed on the last side, and what it sits out is set of forwarding tables. 
02:39:33 So the low level, For the physical network that implement the semantics of the virtual program. 
02:39:38 When when laid over the physical network, so just showing you couple of rules for switch 1. 
02:39:46 Root of the tree. And rules highlighted in orange, first 2 say if we receive packets coming in on port 2 and going to host 6 we should send those out port 5. 
02:39:57 And if you look at the other switches they implement the rest of the path. So the thing to notice is, we're getting a very succinct abstraction of this behavior of connectivity between these four hosts, and the compiler is filling in all the details for mapping this to the physical topology and also mapping it down to underlying tables. 
02:40:26 You can read ICFP paper, but essentially it's exploiting some of the semantics that catch and Netcat give us, in particular the this representation of programs as a kind of automata, and it uses that to systematically figure out how to simulate the behavior. Out how to simulate that came from the virtual network down but physical layer, and also how to implement non local transits of data through the physical network. So this is a quick diagram of the automaton for that virtual program laid over the physical network and the compiler that takes all this, and of crunches again. And then spits out the tables. . 
02:41:02 So I'm a little bit short on time because offer technical glitches, but I want to turn now and show you one other example where functional ideas can be used to solve a thorny problem in these deeply programmable networks, and you might have noticed we completely ignored the control plane so far, given a little model how to program the data plane, but of course lots of cases where the control plane is important, it has to monitor network events like switch it is joining and leaving and ports going up and down, and shifts in traffic demand and taking all the information and computing set of forwarding behaviors for the network. 
02:41:42 And that's important. 
02:41:43 And so far the little functional language I showed you based on NetKat it can't do those things, just implement a pure function that forwards packets but doesn't respond to events. 
02:41:58 I want to show you an example to motivate why implying these dynamic changes might be hard. 
02:42:05 And I'm going to use this symlistic topology here, I want you to imagine on the left two classes of traffic. Maybe public traffic coming off the internet, and traffic coming over VPN more trusted. 
02:42:22 And then we have few network devices routers and firewalls and those are sitting in front of two sets of servers, internal servers and external servers, and what we want to achieve is public traffic should not be able to reach the internal server it is, only VPN traffic. 
02:42:44 Get to the internal servers, various ways to do this, fire walls to identify the traffic, and filter and forward correspondingly, one way you can do this is use the routers to classify the VPN traffic and public traffic and configure the firewalls so the public traffic we prevent them from going to the internal servers, and VPN allow them to go everywhere. So simplicity assume that each firewall is either doing this filtering or kind of open and allow anything to pass through. 
02:43:23 So first configuration that implements our policy, VPN traffic routed via fire wall 1, it's open, and let's you talk to any server, and public traffic goes fire walls 2 and 3, and actually doing some work, now imagine you want to shift over to different configuration, VPN traffics goes to fire walls 1, and 2, and public, shunted over just to 3. 
02:43:51 The problem is how do you implement this update? 
02:43:55 We have control plane that decides traffic loads are too high and want to reallocate router and is resources this way, but how to actually implement first configuration to the second, now the problem is if we are not careful, we can end up violating our overall policy, public traffic shouldn't reach the internal servers, even though these two configurations both satisfy. In particular if attacker sends public traffic and gets to the first router and go update the firewalls it might be the first router still sends the public traffic to firewall number 2, but now firewall is open, and can get to the internal servers that is violation of our policy. 
02:44:44 And these kind of problems and network updates are not just academic notion, they happen a lot in practice. Situations where connections broken, and sometimes links overwhelmed because too much traffic going to certain upgrade, you get a transient forwarding loops and network operators have sort of common heuristics they use to avoid these situations, they use things like make before break idea being the kind of set up a new configuration before you tear down the old, but these don't handle all of this tricky situations that a rise in practice. You can read post mortems from large sophisticated companies and find that sometimes the outages they have are actually caused by these kind of updates. So if you step back and not worry about the low level details but just think what's really gone on here. The problem with these naive, or undisciplined network updates, is that packets, which were carefully program maybe with a nice functional model so satisfy certain properties now being computed with multiple programs, old program and new program. So if I have an appropriate like security policy I have for that example, that may not be preserved by an update, if I have a packet that takes some number of steps through the network through the old policy and finish with the suffix from the new policy, who knows that will satisfy the appropriate. 
02:46:11 The appropriate may not be robust. So if we want to avoid the situations we can provide some criterion, call it a consistency guarantee to basically rule out these situations, and one possible candidate for such a guarantee is that when we're updating from a configuration A to configuration B, to configuration B, we want it to be the case that at least every packet that's going through the network sees a consistent version. So it sort of is processed with A function and B function, or some weird mixture of the two. But you can show that, if you have any packet consistent update so anything that satisfies this guarantee, then it's going to preserve every safety property that satisfied by both particular with the bad ratio showed with network and firewalls wouldn't have that behavior, because the attackers packet would either go through the green or the blue. 
02:47:11 And again the key insight here is, instead of staying down at the level of routing tables or individual nodes think about the network as a whole implementing some kind of function and think about the appropriates that function yewed like to apply to each packet, and you may wonder how to actually implement these consistent updates, and there has been cottage industry coming up with efficient ways of doing this. And want to show general algorithm that we came up with in our first paper on this called two phase updates. And the idea is basically to use versions, and a clever two PROUND protocol to do the updates, first we're going to have every packet or tag or version tell us which function it's processed with, and that tag attached when it comes to the network, and ensure we only use that same function all the way through. 
02:48:09 So want to do an update what we do is take all the forwarding rules for all devices and before we install them we post process them and add a check for the version corresponding to the new configuration. 
02:48:25 We then go install all the rules, everywhere in the network, and notice the rules are unreachable, dead code because all the rules check for the new version, so far no packets are carrying that version, then once we know the new versions there we go around the perimeter of the network, and update the rules that allow packets to come into the network, so one by one they get the new version, and some packets still entering with perimeter nodes that have not been updated, and they get the old version, but some packets enter with the new version and they get that behavior. And then, once we have... looking at diameter of the network, and how long queued we can garbage collect. 
02:49:18 So this is a very simple protocol. It's works with any topology in any configuration, it can be done in parallel, mostly operations can be paralyzed, so it's very fast. 
02:49:29 The main downside of course that requires extra memory because you have both versions of the function in the network, and you need to add this tag to a packet. Nevertheless quite an influential way of thinking and deployed in google cloud and their network update system. 
02:49:44 So I'm just about out of time, just want to pull things together and talk a little bit about future-looking work. 
02:49:52 So, I talked a lot about these two pieces, how to apply functional thinking to programming data planes, and certain extent programming control planes, what I have been working on last 5 years is going one level deeper, and looking at lower level and more flexible abstractions for the data plane itself, and a language called P4 proposed in 2014, Dave walker, and... both involved in the initial design, and large open source community working on. 
02:50:25 And what P4 is trying to do is go beyond data plane where you kind of have some standard set of match action tables you can configure. But actually make it truly programmable. So define the format to the packets coming into each router, and define state variables used by packets as they go across the router and is customize the pipeline to suit particularly protocols. 
02:50:56 And in particular P4 like many like many industrial languages is designed by a committee, it does not have a formal spec. It has a kind of English document that defines the semantics that has a large C + + reference compiler. So what we've been doing is trying to bring sort of foundations to this language. By following the footsteps of many people here and defining the language syntax and semantics completely formally. And then starting to build verified implementation that can compile those programs to software implementations and eventually do hardware implementations and prove end to end theorem showing that the P for program has been correctly implemented but the target. . 
02:51:45 Stepping back a little bit the idea of deeply programmable networks had a many places where PL people can be involved. 
02:51:53 Although it's been going on for more than a decade, still a lot of work to be done. The low-level languages still being debated and ironed out, and higher level abstractions, and initial proposals things like NetKat, and intent frameworks for industry term for similar languages. And no standard here, and possibility for lots more good ideas. And what I love working in the space is it's not a place you have to ask for guidance about what's a good solution and bad solution. 
02:52:32 Because there is literally decades of operational networking work that can help you understand what problems are, and what the solution might look like. 
02:52:43 Now, of course sometimes all that operational experience might turk your thinking, but at least set of applications and users that can give you guardrails, and possibility of transitional some ideas into real product and is open source and industry, and highlighted ways of our work and work by others successful transitions. 
02:53:12 NetKat itself not directly use industry products I'm aware of, ut there's a whole bunch of frameworks that have very high level, and I would say functional descriptions of what kind of connectivity you want, and pretty much all of the major SDN control frameworks have these. . 
02:53:28 Network virtualization I showed you, main technology behind the VMware NSX product. That's their main networking control product consistent updates are using Google Cloud, similar techniques are generally in a lot of routers in the drive I think it's to those writers, there's been a big push for network verification which I haven't talked about today. But there's both teams at big companies as well as startups. That are taking precise models of network behavior and starting to be reading about them. That particular Galois, of course, ESP has been developed a silo verification framework based on NetKAT North ere's a growing community of academic users of frameworks like P4. 
02:54:21 Just closed with a couple of open problems. 
02:54:21 I think there's, again, lots of revenue for anyone who wants to work on applied problems and think about kind of programming in this ritual space to get involved. I kind of categorize them and if you kind of brought bullets, . One language design is pretty wide open. Initial work on low level hardware languages, but still lots of other languages we need. And PL people with tools and teas can have a lot of impact here. One area particularly interested in is how we can think about bringing language-based security to networks. So right now, if you think about interacting with a network through, you know, the socket abstraction OS gives you, basically thinking in terms of IP addresses but many situations imagine wanting to understand how much you trust certain endpoint or path of that end point or middle boxes to the end point, so space for what I'm calling chain of trust networks that let us have abstraction not just who we're talking to but how we're talking to them. And many problems with compilers and network data planes have to be fast, and work both in routers and as well on the edge, and accelerators, and good idea and is compilers how you map programs and down on to the accelerators well. And have immense amount of impact, and growing community using web assembly using packet processing, if you are interested in web assembly, you can do work there. And lots of work in verification, a lot of it has focused so far on thinking about readability properties, does my network connect or isolate traffic from each other. But whole richer verification products including connecting to hardware, thinking about things like timing channels, and of course developing program logics to make these all this verification more accessible and industry, there's a lot of focus right now at the edge. So part of this district by maybe financial interests are sort of this emerging platform with lots of computers close to cell towers, or offices close to self driving cars, factores or farms, and big tussle right now trying to figure it out, you know, what are the abstractions for edge computing and edge network. Look like. And again chance to talk to PL folks there. And then there's kind of if you're not interested so much in these different verticals, but when I think about sort of cross cutting issues. There's state dealing with failures, there's incorporate elements and quantitative reasoningand of course machine learning coming to networks too. And if you are the kind of person that likes low level PL work, lots of fun. 
02:57:15 So let me stop there. I want to thank my collaborators on this work. A bunch of I won't name them all, but a bunch of students, mentors, and colleagues. And if you want to find more paper and slides around my website. Thanks. 
02:57:20 [Applause] 
02:57:33 >> Okay, Andre assured me this is the session chair desk, so I'm going to sit here. I know we're running a little late, but want to have questions for Nate. 
02:57:47 Questions live in the room, and also have Airmeet if you rather type the question you can do so. 
02:57:54 Or watching online, you can type your question and I'll see them. 
02:57:58 And want to remind you if you are here at ICFP you can access videos talks, through the Airmeet platform, so if you missed some talks yesterday, you didn't get a chance to see, you can find the talks, available to you, so I want to open up for questions. Right here, volunteer with the microphone. 
02:58:26 >> You shared a nice example of what we can do programming the control plane. What kind of cool things can we do by programming the data plane. 
02:58:36 >> NATE FOSTER: So thinking of taking more interesting state machines or event loops and pushing to the data plane. 
02:58:46 >> Yeah, what kind of use cases or new things we could do being able to program the data plane. 
02:58:53 >> Right when the slide was glitching I had examples there. 
02:58:58 This is little bit out there in terms of... there is SML group of people called themselves network computing community, and they've had workshops, and they're starting to look at, okay, we've got these router platforms that are programmable, so it's got a parser. It's got some memories and some processing units and these are designed to implement IP processing, and take packets and put in tables, and bog standard stuff, but there is a memory there, and some state. And so you can also implement certain kinds of services directly in the data plane without any performance loss, you can do it at line rate, so first example of this was: What if we use the memory to implement a cacho. So imagine in a data centre you have bunch of back end servers storing bunch of items, and already people build tiered architectures, and memory caches. Whole hierarchy. What if the router itself had a very small but fast cache for the hot items, and there were some really well showing that in fact you can do this. 
03:00:15 Of course helps with kind of balancing load, let's you cut off lay senties and there is work taking certain kinds of distributed protocols. So protocols that do time synchronization, or consensus where you want to coordinate a bunch of nodes and get them to agree on something. If you have the ability in a network. To run the protocol, you may be able to cut out communication, just sitting there. And so severals that do this. And it's accelerating certain kinds of services that might be used by many applications. I want to be clear, don't TLI these are necessarily the future, but clearly possible to take some applications functionality and relocate relocate on network devices and get some per FORPance gains, and simplicity because they don't have to implement themselves. 
03:01:18 >> So I think implicit in the beginning of your talk was the standard kind of motivation of certain patterns and system design you take the performance critical inner loops and run on specialized hardware otherwise things wouldn't be fast enough, that's why we have to deal with special purpose abstraction in the data plane side of things, you talked about sever RAL different generations of that. 
03:01:43 In parallel, there has been a lot of advancement in general purpose computing abstractions like FPGAs, and just curious what is basic orientation of performance cost of using general purpose abstractions today to do everything that you showed us, and how do you see that curve developing? 
03:02:04 Will we reach a point soon it's knot worth worrying about specialize hardware in this dame 
03:02:12 >> Great question. So, I mean if you look back several decades and computing, you see the pendulum swinging back and forth from sort of people get very excited about accelerators but then CPUs good. We really just rather just write C than deal with these. I I don't have the slide deck but a nice graph, Nick McEwan, showing the sort of best processing best throughput you can get on a router ASIC so accustomed circuit for doing packet switching vs CPU, and you go for 15 years about 56789X gap, and today, best router ASICs do 56terabits per second, and singer core CPu packet RO ceasing reasonable workload, just get to 100gigs per second, and that's great effort, and carefully thinking about caches and the gap has grown, and not a hardware person, but can't predict, and friends tell me gap is only going to continue to grow. Certainly for data planes, it seems like the era of software packet processing maybe ending or at least doing the bulk of the work in software. 
03:03:30 >> My questions about FPGAs. 
03:03:34 >> FPGAs you can implement that can compete in terms of through put the. And great way to go. 
03:03:44 MacDougall put FPGA in data centres. I'm not an FPGA person, but understanding there is cost difference and power difference, so if you are doing at scale you may want to spin a chip and get the cost and power savings. 
03:04:02 But I think FPGAs are a great path forward. 
03:04:05 >> Thanks. 
03:04:13 >> Can't resist asking about the communication between the control plane and data plane. 
03:04:19 You drew a little picture of messages various kinds going to and fro, and is that a little network in it's own right, that itself has all this stuff associated with it. 
03:04:35 >> NATE FOSTER: That's right. 
03:04:37 One of the ideas, separating these two you need control network, people explored all different forms of design, imagine completely separate network, out of band isolated control network, that would be very expensive and manage that still. Maybe directly wiring things up, but any intermediate device you have network you constantly have to manage. And data centres at scale people have done in band control, same network doing the traffic going to the controller. And now careful anything you do to the data plane is not severing. 
03:05:18 >> That would be embarrassing, with it being completely dead forever. 
03:05:25 >> My take on this has been, well, we should use high level languages and not make these kind of mistakes and be sure the control always has con connectivity, or should verify networks and make sure the connectivity is always there. 
03:05:49 >> Since we're already into the coffee break. Cut it off here. 
03:05:54 And asking more questions over coffee. [Applause] 
03:06:03 
03:06:03 
03:06:05 
03:06:05 
