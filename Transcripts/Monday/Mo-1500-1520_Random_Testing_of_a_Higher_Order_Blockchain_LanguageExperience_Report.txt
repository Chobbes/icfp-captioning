It's my great pleasure to present our joint work with Tram Hoang, Anton and Leonidas Lampropoulos.
So I'm going to talk about our experiment with applying property based testing to language layer in an industrial grade blockchain system. . And this was an experiment report.
What is the blockchain is a question that I'm not going to answer in this doc, c, if you've been around for the last five years, you could have noticed an explosion of blockchain consensus systems have different levels of expressivity. Or even if your area, whatsoever, but you weren't showing up at ICFP You still know what blockchain is So the question that I'm going to focus on is how do we do programming for blockchain? And what good and bad things can happen o it turns out that if you want to have your functional core imperative code replicated using Blockchain consensus protocol, it's actually pretty easy to join You're just package your code as a module with a state and a function into a model, which is usually called a smart contract, and then you make a proposal to the quorum in the system in the form of a transaction. And before you propose the code to be massively replicated. And diligence, and parser, and do the check in.
And make sure this is the case.
The most important, allocate some of amount of virtual al currency.
Typically associated with the system. Just to compensate all the parties will be replicating the same process of validation, just to double check that you are not proposing something boggles before your code is replicated and propagated to the system, after which every participant in the consensus protocol has a copy of your code. And question how to evolve the state, and use the code already deployeden othe blockchain, that also turns out to be relatively straightforward so one thing that you need to do is to identify the smart contract, the module that you're going to extract with. You're going to go, and then you're going to form a message, which again comes with some money attached to that. All that makes it into transaction, after which this message containing the directives for the language interpreter runs to this interpreter and if it passes the validation and interpreter, gives a new state, the same process repeats, involved parties just to validate that you are proposing something that, after which the changes are being replicated and the system, and the state has been consistently updated. And the reason why you need to attach some currency to that is just to make sure that you don't waste other people's resources. So that's why you are paying upfront, and some of them are going to get these funds as a reward one way or another.
So the question is what can possibly go wrong with this. As you're probably aware, many things, but part of smart contracts themselves, but happened to be introduced. In there, and I'm going to give you a three particular scenarios of how things can go very, very badly, using my favorite characters from Futurama. I mean, Lila, and Professor Fran√ßois. In the first scenario, me decides to score some funds, and she does it in a very fashionable way. By making decentralized content company.
So, in this campaign, the most important function is the one that will allow me to withdraw the donations as a part of the validation in the function withdrawal so she can take note of them and probably think them properly. So me knows that the type sound as guarantees provided by the ... if there are no exceptions, it will draw no exceptions.
Amy is wrong is the judgment, contrary to expectations, B is informed. MLnd this is certainly not the center expects and in tourism and that if a type has done its exception for you. She is wrong. Let's see what can possibly go wrong, out of them.
So once me has written her contract and deployed on the blockchain. She has no way to take advantage because the contract and the state has been have been massively replicate it. After that lucky start to get some donations. At the point decide to exercise her her mighty campaign and withdraw the donation backs The best thing happens, if at least one of the data submitted their own data. So the exception is strong, and the contract blocks this money forever so neither the backers can get it back. If the contract is structured in a certain weight neither me can enjoy for cash. So this is certainly not a great scenario.
Let's see what else can go wrong with of language frastructure so now we are focusing on Lila, who is a language engineer and Lila is in charge of maintaining the reference interpreter for the language that gives the logic to smart contract deployed on the blockchain. Following the suggestions by the users.
Sorry, little decides to add the operation for computing the power of a certain features certain days, or certain arguments and GHR implementation is perfectly correct. The only problem is that it takes linear time in the size of the argument, to compute the power of number.
Remember this is computationment in that computation that is going to be validated by multiple parties, not just the one who deploys the respondent transaction. The problem was Lila's code is that it disproportionately charges too little of cash for computing the power function where the cost is linear, the implementation only charge logarithmic costs. Let's see what can go wrong now so now when this is interpreted this interpreter is a part of the time for the blockchai consensus, but we have a discrepancy, the fact that transactions that have to do with computing the power of a number of very cheap to propose in terms of the funds that needs to be allocated for them, but they are quite expensive to execute in terms of the real computing resources and it doesn't take long for someone to recognize that fact, after they will close it was messages to cause contraction contraction, and eventually denial of service and then I will serve as this is a real pain in blockchains as somebody with, with my older posts and particularly unpleasant, when they're called cost by the language implementation, not some serious networking issues.
Okay, so that was probably the most exotic one let's focus on Professor funds fourth, who decided to solve the performance issues in radical could processing. Everyone likes, professor...o, this becomes the de facto part of the client and everyone starts losing this compiler for every single smart contract in. The only problem that this compiler is too cleve implementing certain optimizations, it hit famous complexity results social circle control flow analysis, taking a cubic time in the size of the program. And again, it doesn't take long for someone to recognize the efficiency and leader of the system with the contracts that are very small, but those kinds of optimizations look into the congestion and to the denial of ervice in the system. Okay, now we have seen three scenarios of rubber plants are unpleasant consequences of what I'm going to go language letterbox. Anthose are not the backs of the smart contracts.
Those are the bugs in the infrastructure that executes the smart contracts invalidate the smart contract, such as the type checker and an interpreter, such as the misalignment between the cost semantics and execution, and real education costs, and finally the box in the compiler.
Okay, so in this talk, and then the rest of it, I'm going to tell what what we did in language layer of the real world blockchain, using tech also firstive oallvery small, smart contract language which is built, or based on system with some extensions, it's intentionally non Turing complete it doesn't but it has recently different effects and all the interactive smart contract is structured as communication between independent actors. So this is a practically relevant language it has been adopted by a block chain and there are several 1000 contracts within it and when users are using the code returns filler daily If you're interested more in the details of the language itself out, ee the usual suspects, such as the type of structure and the type application. Also has no camo style imperative fragment with reading, writing, mutable state emitting events, and sending the messages, and the context of look like that you don't really have to read this, you can just notice that well, there is such a contract definition. There mutable fields and the whole structure as conditions that most time results in sending and receiving messages. So one interesting detail about implementation of silver, which is by the way, Don is interpreter, which written according to best practices in the monadic. So, monad. So not only the use of molecules quite justified so you can see the Oh camel led by innovation and highlight the the structure of the interpreter will be essential for engineering for the best thing we are going to adopt the standard mechanism of property based testing, write your properties as Boolean functions to implement the generators they played random inputs and write your properties as Boolean functions to implement the generators they played random inputs and nd has been replicated for multiple languages, and settings. Okay, so the property based testing becomes really interesting when we want to test metal properties of the language, such as the preservation so e key part here is a most of these properties.
They're really conditioned on certain vendors. And as you might know, even if they wanted something as simple as the type there's a reason, we really need to generate the term which is well typed in a certain context and solution to that which has a very little chance to work, is to generate the environment. The term and the type and check if we are lucky to have this to be well typed with regard to this type. And if not repeat this process so this interesting part of chicken the meta property itself, and much more clever solutions used to write the generator that first purchase well form types, and then based on them, reduces the chance, and this is something that has been studied quite a bit on the last few years years.
It's very much recognize to be a non trivial problem some solutions to that. I found instances in the framework section, nd more recent work by some of my coders who tested non interference Using generate on well for him to programs. Okay, so we follow this approach and we decided to adopt one of the state of the art schools for property based that provides good possibilities to generate types and structure data.
And quarter of this work. Had quite a bit of success in academia and used as teaching material in the software foundation Sed as teaching material in the software foundation series. So one of the reasons that we decided to switch it is the fact that it's very well formed programs it's also has a reasonably good interaction with which is a language in which still has been implemented and also has some advanced features such as fast and based feedback, which simply we didn't have to.
We some interesting gotchas that we have figured out or adopted from the published report, when engineering our tests and approach to seller language layout. So the first challenge that we have faced is how to generate interest in programs in the fragment of system and what makes system layout. So the first challenge that we have faced is how to generate interest in programs in the fragment of system and what makes system quantify polymorphic types, or this is not particularly difficult, we can do it in a recursive manner by first Remember in which, which type variable, we have in term, variable as free. Ands fundamental So that's relatively easy, somewhat more interested in is how to generate type application so this rule doesn't quite do justice to the problem.
So, I'm going to write at that rule. North so the main discovery we made to generate the type sigmas. And generate, tau, and tau prime replaces variable ex-, in the Ta, u and the x in retro specific . And so identify close symtack TAM ite idea is to take the type sigma philosophy and identify closed subtypes type variable so that as simple as it sounds, was just a driver or so and recording of types. Well, in reality, the algorithm was slightly more tricky, because we need to keep track of, of the type and also distribute frequencies so we wouldn't get very boring subtypes.
All the time. Okay, so that was one discovers the second one has to do with how we harness the language infrastructure already in place to facilitate the assessment, and for that. So the main motivation for that was to test a particular component of Silla compiler, which implements a control and type flow.
Remember in functional languages, the control flow analysis typically over approximates the flow of values to variables, was the main application of that being optimization function inlining and somewhat more vertical analysis approximates the set of ground types that flow to type variables, who is he main application of that being more physician, unsurprisingly to test these both we need some version state collection semantics.
Hat indeed flows to the type or value variables and primetime is correctly approximated by. The only problem that we didn't have the semantics of it. The only thing we have is our reference interpreter, and has been written in monadic , and how to abstracts the interpreter, and some of this affects, MOITH have corrected. And long story short. We only had the change the instances it. So it would report all the states. And this way, we have implemented someplace to he were P with you inn... so here to hear about the full box.
And this is was the box as of camera ready submission, which slightly increased since then.
There are some not worthy specimen here.
That happen to do with misalignment between the static and dynamic semantics of the primitivesprimitives. And have two box, that deal to denier of service.
One problem of interpreter itself. And mentions in the example, and finally, bug in the compiler, the counter flee left laneh made counterflow take pretty much forever so we had to do some contrast conservative projections that are going to be compiled you can also see that some of these bucks are really known so what we have done we have taken the previous commits, where this came from last reproduce before they got fixed, and we automatically generated programs just to make sure that our framework posts will be able to produce this box, but 7 out of 10 entirely new.
So, just as the last example.
So here's one of the box which in retrospect is extremely silly, and I wonder how the developers missed in the first place.
In the first place, but this is what is happening here. So here we have a type abstraction with two names of the same type variable used twice. And what happens is that the interpreter should really think that the type. The type of the variable we want is V prime.
In fact, it decides at runtime due to shadow and the type of we want is this We prime, which is closer in terms of scope. And variable A, 161648. Truth been detected. And I believe it this is the time I have left, to take away from the experience report, something might find useful, experience of... several credit... ish PSHL blockchain based on system using which as a tool and discovering several critical bugs. There is a simple technique of and sub-Constitution for generation the wealth out FF system.
Type instantiation. The real world usage of the technique of monadic interpreters for implementing collection semantics, that's static analysis. And if you want to see all that in action, we have an artifact Publishing's and others so feel free to download it and take a look. And this is all I have for today. Thank you so much.
