>> So if the check fails the program crashes, right, you looked at number of benchmark examples, did you find anywhere the checks fail.
>> A great example where it fails is lock free data structures. So you have communor communication, essentially on the fly communication between concurrent tasks utilizing something like the lock free data structure.
Then, then maybe you'll get entanglements. Another common case explicit just locks, right, but to be honest is extremely uncommon and inefficient parallel programs. It's much more like a concurrency issue that apparel is an issue right so in general we're finding it too there's a little bit of concurrency that gets injected into the program. You might start to see the possibility of entanglements. All the examples that you have been looking at fairly uncommon. And able to do Delani triangulation we're able to do parallel breadth first search with like the fast like sparse offerings like hash deduplication, like it's really surprising what you can do it disentanglement and not run into this entanglement problem..
>> You mentioned you can detect entanglement statically, but it's not precise enough. FT have you thought of combining the two and sort of, when you can prove disentanglement not doing the dynamic, We are already combining the two because of a we do immutable. We allied any sort of read barrier for immutable data. So in some sense, we're already combining the two and a little in some extent. But yeah, it'd be really cool to have a much more powerful static, perhaps like a typing system that could give us more information. Yeah and the thing I didn't have a chance to talk about, the entanglement,entanglement,which tracks potentially hazardous mutable cells at runtime, it works fairly well but we have identified a few places where if you're not careful, you know, it could still not do a great job and I think that could be a great opportunity to, yeah. .
>> So do you need entire KOFRN TUtationtional graph at runtime or could you possibly use like a partial or total ordering the one that actually has maintained at runtime is very partial essentially only the tasks tree, and you throw away all the old stuff that's in the past.
I mean there's some nuances there that are kind of hard to get into in a short talk.
Because we encode vertices in the graph and a clever way and kind of old vertices might linger around and we can still query hem, but actually look at the space cost of maintaining the computation graph, it's essentially just the number of active tasks.
>> One question.
>> Hi. So you mentioned that stuff like LOC3 data structures, ifif. Am I understanding correct that programs can't run, just error out.
>> So it is possible to extend that barge, garbage collection.
Switches to a slower but a version that will still handle that sort of thing. Exactly, yeah, this is this idea of, we're hoping to pursue this idea of entanglement management, we're calling an entanglement management, where at the moment you detect entanglement you fix it up, and and the intuition would be that you will pay for entanglement when it occurs. I mean, we think that this technique basically opens that door,door, to investigating that.
Thank you, [applause]
