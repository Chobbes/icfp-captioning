I'm Irene Yoon, PhD student at the University of Pennsylvania, and I'm going to tell you about formal reasoning about layered monadic interpreters, this is joint work with... and Steven Keuchel. If thes so today we're gonna talk about free monads there, a data structure for representing a cycle programs here we consider a computation was interactions with the environment, our reads and writes to a state intuitively or a tree where here you have a program, interacting with the environment with the event where you do a read from a reference cell X for example, and brand continuation, and first is continued with result R, and rest is continuation, and event with right to reference Y with different natural number values. So typically in a monad, you have a parameterization of monads are of type two type parameterize without result type power of free monad you're also parameterize by a family of events, which describe the operators and the language. So in this example, the type of this would be free memory E, not where memory E or the read and writes to reference cells. So given this data structure, how to actually give us semantics to it. Using monadic interpreters given this roughly OCaml snippet saying that you have a right to a local variable x and a right to a reference cell Y y which should be ready to memory. You can encode this as a free monad that may possibly return a natural number of value where you encode the reference cell by saying you have summary. And then the local variables are encoded with multiple events.
Now we can give us semantics to this in a layered fashion. If you know how to fold over the structure of a particular free monad, you can have INTERP constructor, which folds over a monad and given a handler that is a concrete semantics to your memory events, you can then go to a state transformer which represents the memory on the heap. And then you're left with a free monad with the remaining events which are local environments. Then we can give a full interpretation to the event by giving another layer which, given that you know how to fold over the structure of a state t apply to a free mo monad, you can have an internal state function, get a handle of the environment. And then the resulting monad would be nesting of some state transformers and then now you have the remaining free monad with no events left.
.
And at each layer of interpretation, new notion of equality, you can imagine, though ou have the syntactic notion of equivalence. Whereas on the free monad you can have a free monadic prevalence, assuming that you have an equivalent free monad. You can imagine that you can define some kind of notion of exceptional quality, which is an equivalence up to the resulting environment of state. So the goal of this paper is how to bring modular reasoning and semantics for such layered interprets. So just to situate this work, I'm going to give you birds eye view on all the related works this has been built upon rich tradition of nestss nested interpreters since the 90s where people have used nested interpreters to give us solution to the expression problem in very popular programming languages such as Haskell and nested types are very useful and free monads allow us to use free monads and the total type theories such as CoQ.
So, this particular work is built on top of interaction trees which is a Coq library, a data structure which is technically a reader monad so what is the problem that we're trying to solve, as part of the vellum development team hich is a formal semantics of LLVM IR in Cocke, we've developed a formal semantics for LLVM IR a realistic production language of production level language using interactive trees which has this layered form of interpretation. So when we do this, we get interpreters at each level which is extremely useful because, as you can see this diagram of stack is very complicated and see the last layer have a choice of interpretation we can give to non determinism which we have other last layer here. And on each layer, there's also a lot of equational theory involved monad laws and more. And the difficult thing is there is a lot of boilerplate metatheory, where there should intuitively be structural rules preserved through the layers of interpretation. So previously we've identified that the semantics is somewhat extensible kind of limited, but the reasoning principles are not reusable and in this work. I'm introducing that we're going to remove all these extraneous words so in practice what this looks like, in our case study we've done, simple imperative language to assembly language compiler correctness proof and then the middle of our proof we've identified that we've had to continuously apply the same structure rules but different layers which incurs different proof obligation on each layer, and also redundant boilerplate whereas the key idea is that in our new proof, we can actually identify the structural rules, which are preserved throughout interpretation and we develop the necessary meta theory to do this. The contribution is that we have a new meta theory to reduce the boilerplate and formal reasoning about their monadic interpreters and then the way we also introduce new abstractions of interpretation.
And using this we can do algebraic and heterogeneous relational reconcile reasoning which is suited for reasons such as compiler corrective statements. And this is all a oq library that is used, sending the traffic increase framework and if you didn't read all this, the takeaway is extensible meta theory. O kind of going back to the initial example right, what's the problem, have the right layer of abstraction? So once we have this free monad you say Oh, as long as we know how to fold over the structure of a free monad, we can write an interrupt function over it. But then once we have a state to apply for a free monad ctually use a different function called interstate because the -- so we need to introduce the right kind of abstraction, This interpretation, we want to introduce a new abstractions so that this last layer, really, is the same kind of interpretation so that we can lift the structural rules. So how do we build layered interpreters, this is just type signature of the interpreter function of the original entry library. Given an interpretation function for a given free monad your event type, just to remind you, that's the family of events, type, type, that describe the operators of your program, and tar gets monad, and target of interpretation, so given handler give you semantics for each event in your programme, you can take the free monad, and of these events and interpret into the target monad. The problem here is that the interpretation function as parametric and its target monad. So, the key idea is we want to interpretation function that can be layered.
So we generalize the notion of a free monad and define something called an interpretable monad, and we try the layers of interpretation, using higher order functors, right. So now we can help a new definition of interp. And actually two new types we see here on the definition, we first have a layer type and index monad, I'll explain throughout the slide, a monad transformer and a higher order functor, which lists the boilerplate meta theory. And what we call an interpreted monad is the now newly parametrized source monad, , which is a layer rigger events which I will explain. So given the this layer of interpretation but we've seen earlier. Concretely, the type of layer will be the set state transformer with the state of nheap and then the index monad, which is a higher order functor representing respecting iteration, and the index monad is an index monad with events with what we characterize as having operation called trigger which represents a monad that has minimal, computation for performing an uninterpreted eveevents. And then the target.
Here is a state T transformer applied to the free monad with no events left. So, the layer domain should respect the necessary structures rules.
Right so now that we have new abstraction for defining the interpretation function, how do we actually get a he OOE conversational theory that can compose. Right, so relational reasoning on monad is not new.
The most like common laws monad laws as we seen in the previous talk, you have the expected unit, and return operator, and bind operator is associative.
And we introduce a relation called equivalence moduloR, theory monads with a parameterize relation r. O this not only generalizes the monad laws but it offers a relational program logic for monad so in practice we can reason about program transformations, with postconditions on the resulting values where R post condition or the resulting values.
Furthermore, we have a we have some structural laws that we characterize this equivalent to hold. So, in order for this to be a useful equational theory, there's some expected laws such as monotonicity over the parametrized relation. And if the relation that you're parameterizing over as a partial equivalence relation to the results be also be a partial equivalence relation. And then also the relations compose a somewhat expected manner. You can find interpretation laws, enfores laws, and in the paper if you are interested. So, this kind of parametrize relational reasoning I just wanted to show you a couple more rules are nice for kind of having this kind of heterogeneous reasoning about programs transformations. So you can do reasoning on pure values were. If you were to want to relate a monad that returns an element change with another one at that returns an element, when the related results should be related to each other and it's heterogeneous in the sense that A1 A2 not necessarily have to be the same type. So it can be monads returning different values. And then we have the closure property or if you're more familiar with logic side like this is basically a property for buying, where we can relate to monads which are and they want to want me to do X, relate off of per condition RB if we know that the prefix is related on RA and continuation related postcondition for all related RA. And as a result we have composable equivalence for layered monads and we say that each monad can have a particular notion of equivalence with all the structure of properties and additionally the structural rules for iteration and interpretation should be preserved. Pointer, that rule, that rule, and basically saying interp, monad morphism that commutes with fine and then if it's an interpretation of a return that should be equivalent to return. And then, this is kind of the behavior of what it means to be trigger and to remind you of the definition of trigger trigger is the minimum minimal impure complication of an interpretable monad. And these laws compose in the sense it's unnecessary to introduce new definition of equivalence and proof new structural rules for every combination of layered interpretation. So in conclusion, we introduce and accessible meta theory for acceptable effects, and then the paper and the artifacts. We got the badges. We have a Coq library on top of the attraction tree framework. And we also talked about during this talk, we have a generalization of automatic injection of handlers with combinators called --
subprime over and we have various instances of the equational theory of monads and monad transformers including like state and the weekend strong by simulations haracterization of interpretable monads respecting the theory of iteration and and also notion of an image of a monadic computation which characterize the name of a monad case study which is and to ASM compiler this is kind of a sort of a diagram of the tech cost dependencies of this project and the green part is new part red part, are some of the dependencies from the tree library, thank you for listening I'll take any questions.