Hello, everybody.
So first off I have to say this article we're talking about is part of the linear Haskell project, which, despite the name isn't really about Haskell, more about the linear part. It's Haskell because we have to choose a language, because I Val my sanity.
Usually in my first slide I put picture of all the people that worked on the project, and quite a lot now, and I kind of gave up.
So instead I put a little timeline. And today for scale.
So what's linear Haskell. The goal of linear has call to add linear types, and we made a lot of progress, to Haskell, or any programming language that already exists in a certain sense. So we're focusing on Haskell. So I'm not going to mention any other programming languages. I'm sure it works in anyway.
So explain for a second what a linear type is, the idea is to add an extra function type.
There is a number of ways to do that. More or lessee equivalent, and the way we done that, is just add a new arrow, which we write, a potent, Aerio.
And function type linear function, read that way.
Promise, use the argument only once. And say, if it's consumed only once, then the argument and consumed exactly once.
And, oh, New York City you would say, why do you need something like this.
Why would anybody need something like this. That's an excellent question. do you need something like this.
Why would anybody need something like this. That's an excellent question.
The thing is producing a value, linear function from A to B doesn't buy you. Not just, okay, made a promise, but it's not really useful to make that promise. What is useful is to require linear function from A to B it let's you constrain the API from A to B. You can instance force some resources to single thread fashion. And once you force single threading, then you can do all sorts of thing.
Like allocating data with Maloc directly, bypassing GC and still memory safe. Not going to quite do that today, because it's a bit involved for slides. So we're going to do simpler version to have immutable data structure, so I'm going to put up some code for mutable array.
What's interesting about that is, normally you don't have a mutable array but I have a pure interface so really what I'm saying is I have a data structure that is pure array, but under the hood, I'm going to implement that mutation is presumably that is much more efficient. Really expends what are you doing. So give up sharing, so not free. But that's not the point I'm getting at.
The code on the right is really ugly.
And if you look at the code on the left, written in. Mezzo language, you know exactly what I written naturally. And here swap to values, and all the examples in this talk extremely contrived because... slides.
But... yeah. I'm a bit jealous.
On the one hand it's understandable, Mezzo is language best to speak about mutation of data structures, includng arrays, and dedicated type system, and I have general syrups mechanism, single type, I would expect some degree of boilerplate.
On the other hand jealous and the syntax highlighter, named arrays A's, and pass that as the keyword as, doesn't exist in Haskell, first it's very funny and highlights how ugly the code on the right is. And how many times I wrote A's, and so made the effort to make it look as silly as possible with the prime signs. General idea, I named the same array 4 times, we're accustomed as a pure functional programmers to return a new data structure when we modify it. But in that case we even need to return a a data structure when we read it. So considering this, this is just not very nice.
Like, half the code here is renaming the array. -- not half the code. But significant proportion, obscures the idea, and makes the experience not very pleasant. And so my users -- that's you by the way -- I'm not going to use that. And honestly, just figuring out something is single threaded and any computer can do. Doesn't need me to tell you yeah, yeah, because it's prime and not A.
So I wanted better.
There was, by the way, four other authors by the paper, I don't mean to represent their motivation, everyone has their own, that was mine. It runs a bit deeper than this. And today focus on that. And if you want to know more, you see me tomorrow.
The important point, and frank did a lot of my job for me.
Thank you.
Is how does GC in that case.
Handlele. And how does GC do work for me.
So I'm going to clean up this so these things are called constraint they appear both in in the type inference algorithm and also n terms, which is going to be okay. Just clean it up so that we can see. So when I'm doing inference, much like in the previous talk. So GC talks down the term, and license plate aL I occasion, and see constraint, and say by the way if you call nub you better be able to satisfy the EQ constraints, and second phase that... and on the other hand, every constraint more or less can be manifested to the left of far arrow like this. So I even if I don't 100% need to. And I'm saying when you use API, you need to do that and that's exactly what we want, we dealt with it or yell. So that's the core idea -- getting ahead of myself. Important point we need, is how it this fat arrow implemented. Ultimately, to a thinner a perfectly normal Eric, so in the language of GAC it becomes an argument.
And so... that's where the ID come from. Let's add a new fat arrow with a person one in front. And it's meaning, is given by the fact inside need to pull that off give me a minute, write code, with linear constraints in it.
And the meaning of this is just given by the linear arrow. So don't really need to add any real power to GC. Except to tell GC, you can infer that. So the type of set doesn't fit the slide. And try to make it smaller. Size so big probably going to pull it off. Realized that this morning. So I wrote set, and there are things you can write code, the same function, and now, there is boilerplate.
But not like silly boilerplate.
Something you notice, there is single as on the slide. It's really convenient, there is single A's on the slide, this is not the linear quantity any more. The function doesn't say, I'm going to use a single M...
knead it Instead what the only linear quantity that we have is this readwrite constraint, which says I can read and write on my way.
And because it's completely implicit, to see it, I just get an error message. If I do something silly. That's what we set out to do efforts, as it happens. ... there was another thing in linear Haskell that was displeasing users. If I'm allowed to come back to what I said very early on. Producing linear function is not very useful, what uh-uh need is require. So if I am write a mutable array library have to ask for linear fashion at some point in the way, it typically happens is, when you create an array you don't return that the array, because it would be unconstrained. I don't really have time to go over this. You have to take a function that takes an array as an argument, consumed it linearly and return something that is not linear, that's what the earthing means.
Yeah do you like that. Most people don't. Not as bad as it looks in a way. You will have to kind of scope, the resource exists in this scope, that's why I call a scope function, and why not have the scope be de limited by a function. The thing is does really cause problems. I gave an example here, very tiny, ugly, but does cause problem down the line, especially with several arrays, and want them to interact, and quite BESy.
Nova Scotia have to go after the, after the talk.
Clear.
>> So it caused a lot of problem, and not pleasant, and not the way people want to look at array. And a lot of people so far that have designed linear API has gotten this wrong at least once. Theyirect style, and the API was not safe.
So at the very least is not intuitive. So enter the linearly constrained. It's hard to implement the linearly constrained than just in your conference in general. I just a special constraint that has some properties because it needs to change and weakening. To be completely useful. But then you say okay, I'm creating a new array, licensely, and just say that. And I think it fit before and it was a bit too big. It looks okay.
And then, I wrote the from list function in the direct style, what we want to write from from list, and also this is not the right for form list, and said all the examples were really contrived. That's the best example of examples being contrived. I mean.
And so how do you pull that off?
Because so far -- it's not that hard. So you can design declarative testimony with constraints and the system is close enough, and the linear Haskell without constraints so that the sugaring becomes becomes obvious. You elaborate that with a constraint generation algorithm. There's a few things to think about because of linearity. You saw the constraint. Some people have already done that glad that they do work for me and I will have to read the paper, this 15 pages of technical developments so goes into more detail. Until then, can you follow the tweag blog where I blog about the subject from time to time. And here are the slides and QR code also brings you there 