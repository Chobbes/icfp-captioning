I'm a PhD candidate. I'm here to present my experience with different kinds of compositions of high-order functions. This experience report was born out of a separate research project seeking to understand how well students understand dpigss of high order functions in general.
As part of this property I was tasked with creating new problems for the beginning of the certained course at brown.
The problems needed to be solvable with the high function orders on list and needed to be of an appropriate difficulty.
This proved to be a much more challenging task than expected.
I can propose a number of problems but all of them appear to be on the two extremes of the difficulty speck frum. I had the ability to generate problems that looked to be easy or problems that seemed to be much to complex but nothing in between in this sweet spot. What really frustrated he is the fact that I couldn't explain to anyone why this was true or even the difference between the two collections of problems. Why were the challenging problems challenging? After sfaering at these problems for months I came up with the hypothesis to explain what makes some of these problems significantly more challenging. Over the course of this talk I will present the hypothesis and some evidence and how and why we're seeking to expand this experiment even further. Before I get started, we are currently restricting ourselves to higher order functions on lists. Specifically higher order functions with the type signature on screen. These were the types of high order functions that we're working with in the course which is why we use them. Students were, in fact, restricted to a small subset of these high-order functions which were presented in the course. Pop quizz.
Consider the two following ways of composing fight-order functions. I will give you a moment to read over them. Which of these would you consider easier for students to understand and use, and which of these represents a larger set of possible programs? Really stop and any. I will give you some more time. If you're watching this video on your own, pause and really think it through.
This is vital to the rest of our story. What does your gut say? I will call composition A pipeline and composition B structural.
Let's look at why, starting with structural. Let's just do a bit of type analysis on this example that we have. We will wrap that example in a function called example fun which takes in a list of A and produces some type B. Of course, that means that L must have that same type, a list of A. We also said that we're focusing on list higher order functions. So we know HOFC will take in a function and list and output something. In fact, since it takes in L, it must take in a list of A. Meaning that it's fun L emust take A. This is inner.
We can fill in those lines as well. We can also say that H 2 FC must have the same type as example fun. So let's fill that in. HOFD is one of the high-order functions. Let's put that shape in here as well.
Similar to before, we can constrain the types based on the output argument which here must be the same as the one here so let's do that. We can also constraint the types which is inner and has type A. I would love to put that straight in, but I lose of fact that this must be a list. Instead we do some substitution. We will anies say that this high-order function takes a list of type X and then will replace all instances of A with X. It is a jarring change at first, but notice what happened. L is now constrained to not only be a list, but a list of lists. Said another way, this composition only works if the type of input list, L, was a doubly-nested list, and a similar argument works for any number of high-order functions composed together in this way. I can only nest high-order functions in structural composition up to three. I cannot not have it if it's two dimensional. The type constraints don't work out. This is why we call it structural competition. The competition must mirror the structure of the input data. This in turn means that when given a lift of the high-order functions which students were, then for any given list, there is only a finite number of ways that I kon structurely compose. The list high-order functions impose dimensionality constraints and then the high-order functions nested inside must confess those constraints. Now, of course, I can fill in this eat the bottom with in one of any number of functions. The set of possible solutions is a bit misleading, but still there is a significant constraint imposed on the space and synthesizers or students exploring the space searching for solutions should have a relatively easy time but easy relative to what. Let's it do the analysis for the pipeline.
Example fun once again takes in a list of A and outputs B which once again means that L has type list of A. HOFA must still have the type signature of a list high-order function and must still output the final result of type B. HOFB must be a high-order function and take in L which is a list of A. This A then constrains the type of its funarg. We know HOFA and HOFB are equivalent. A list of X.
That means that the funarg must take in an X. We're done. We see the key distinction between these two types of compositions.
I am no longer constrained by my input type in the same way I was in structural composition. I can, in fact, keep chaining pipeline composition indefinitely similar to the piping operator in U nix and other processing pipelines, hence the name. As long as I cannot to line-up the out put type of one to the input of the next. This means that that student as a synthesizer is likely going to have a more difficult time as a solution they're looking for can have unbodied size and loser type constraints. These list of X types can be anything as long as the next step in the pipeline accepts that same type of thing.
Does this difficulty match your intuition? It certainly didn't match when we started and it went against the intuition of many other experts we spoke to, but it does line-up with the experiences we spoke about earlier. In almost all of the examples of this gap I mentioned earlier, the easy problems were structural in nature and the more difficult problems were pipelines. Observing this apparent distinction in the wild we set about creating a more controlled instrument, a course assignment that would test my hypothesis that students have more difficulty with pipeline composition than with structural xomp sigs. So what is in an assignment? Well, for any assignment, a student takes in a problem statement and produces a solution as out put. So to design our assignment we need to both pay attention to problem statements and to solution structure. Let's look at the latter of those two. There are a lot of challenges involved in wrilg full working code and not all of knows challenges are germane to our question about composition. So instead of asking students to write code for in assignment, we gave them a prompt for text in the hopes of seeing their high-level planning strung tour. The full text of this assignment can be found in the paper but the instructions are roughly summarised here. You may have noticed that the instructions mentioned a box with examples.
We will come back to that in just a moment as we talk about how to present problem statements, the other piece of this puzzle. Here is one standard example of a problem statement. Given a list of lists of numbers, I will put the same lists of list of numbers but with the number five removed from each inner list. The issue is that most people who have had some experience with high-order functions will quickly realise patterns, like remove probably means to filter, from each indicates a map and we're basically already done. It is a map of a filter. What is even left, we have given away the statement. We tried alternatives. Specifically, we took inspiration from a previous education paper on high-order functions which used in put output pairs as the problem statement. This is what this looks like for the previous problem. The assignment gives them problem statements that look like examples like this and asks them to generalise to those plain text solutions or explain why that is difficult or impossible. Our students had, in fact, completed this task from the previous paper that we mentioned before starting our task so that we're already familiar with this input, output pair format with both our problem statement and our solution formats decided and with hypothesis in mind, we set about our experiment. Students were given seven problems total, three each with structural and pipeline only solutions, and one impossible problem. The problems were presented in a random order except the first problem which was always fixed to avoid giving the impossible problem first.
How did they do? The detailed numeric results are in the paper but they are summarised in the chart. We see that nearly all students correctly identified the structural composition questions and less than 75% of them correctly identified the pipe hin composition questions.
There is also a high degree of uncertainty represented by the imprel owe portions of the bars.
This is reflengtd further in the written text results. More students had the correct answer for the correct rope on the structural problems than on the pipeline problems. There's a more detailed breakdown of the written responses in the paper.
We know that in isn't perfect.
There are valid challenges to our choice of representation and this is a small sample at one university. Our goal with this work is not to claim a definitive answer, but to be a starting point to inspire this community to investigate this phenomenon further. To that end we are currently actively coordinating a follow-up study to this work across multiple institutions in multiple nations working in different programming languages. If in work seems interesting and you or someone you know might like to come on board, please reach out. You can find a detailed write-up of our current research plan on the screen. You are welcome to reach out to me personally via email offer on Twitter. We have owned an interesting distinction between different ways of composing high-order functions and a perceive difficulty gap between them. We have given the names structural and pipeline to these two kinds of composition and we have provided a small sample of evidence suggesting that students do actually struggle more with pipeline composition than with structural. We are coordinate aing follow-up study and I look forward to hearing from you and answer any questions you may have. Thank you.x