
>> Welcome to my talk, this is joint work with Stephanie and Robbert, he's here but can not see him. So this talk is about message passing. Usually in language like go and rust. Have a channel type in roster, there's a split into receiver and sender. And on those channels you can send messages of have a fixed type. But session types are a little bit more advanced, they are more flexible. So the type of the message that you send out a particular moment can depend on the state of the protocol. And that state can change as you send more messages or receive messages. And this is handled by linear types. So let's look at a simple form of session types, binary session types. Here we have binary channel variable C, which has session type, and says we're receive that message, and receive natural number, and type will change, and after that you are supposed to receive Boolean and then send natural, so binary session these come in pairs, and other side of channel has dual type all the sends and receives are interchanged.
So we have send and receive, and also have form of choice, one party decides, it sends a Boolean orbit saying I want to go to left side of port call, or right side, and the other party has to deal with that choice, we also have recursion to deal with with infinite protocols. And interesting point of binary session, Charatoniks ordinary types, so you can send as messages over other channels, on the other hand, multiparty session times, which there are no two participants, but more than two. And in that case, we annotate these types with emphasis and the indicating, with whom you're communicating so for example in channel c zero, that is communicating with participant one. As far as sending a natural number, and then it's receiving national number from participant 2.
There isn't some kind of rule about these things consistent with each other, and not just send receive match, but that they are done in such an order there is no dialogue. So a lot of research done about session types, but here I want to focus on two families of language, GV family on one hand and multiparty session types family.
Main difference GV has binary session types, and multiparty language has multiparty session types, and you may think one is more general THANT other, but that's not really the case. GV, you get that freedom, that main... people are interested in. Duality and linear typing, and then configuration of processes look like a tree, and this tree shape is I couldn't get predom, So here each vertex is a process, and align indicates a communication channel. On the other end with multiparty language you have fully interconnected topology, and then ensure global consistency check.
This means GV family of language you can have dynamic spawning, and multiparty language you usually have one static session, at least if you want to stay in the dialogue free fragment.
GV family of language you also have channels of first class values, and multiparty languages you usually do not.
And GV, you have -- it's all embedded in functional language, where as multiparty language usually in pi calculus, this work we want to combine the two to get all the strengths of the left and more expressive types of the right, and call that combination MPGV. What does that look like?
And how are the processes kekked. Still have a tree. But now in the tree are these small sessions with multiple participants, and in each session, freedom guaranteed by global and local session check, and globely over the whole session, developed freedom insured by the tree structure.
So the main contributions design of the language, language which you lamda calculus, and multiparty message passing channels and dynamically spawn, and first class values, and we have recursive types and choice, and other features.
And... using this we can see that in our language, we really generalize the old GV to do that we have to add one additional construct that we see as useful for modular programming.
So the key property here that all session time peep are all interested in. Type check you guarantee dialogue freedom.
And that occur here, receive a message, you have to wait until the other side actually sends a message and that creates danger for dialogue, and here, if that program type checks, that can't happen. And method here is all mechanizedmechanized in fork. So let's look at what the main constructs are. And here we have a fork.
And this is an a-fork. And inspired by Carbone and what this does is combine channel creation with transporting, and essential for keeping invariant configuration looking somewhat like a tree. To this fork pass number of closures and into the closures a channel will be passed and fork also returns a channel, so what we require here is factor of session types of each channel are consistent in multiparty way.
And each has to return unit in the end, and standard linear unit that guarantees this actually consumed session type fully.
So here, you see picture of configuration at runtime, so the left you see this process is trying to spawn some children, and then, it just grows an additional session, but environment configuration looks like that is then preserved, here are simplified types of send and receive, so in the real system, you have this choice, a little more complicated but here do without choice, so sent has input as a channel, which we're now allowed to receive. And also a message we're going to send and then returns to continuation channel with the new type after send has been performed and receive the other way around returns the message that was sent. If you're allowed to send channels as messages that also has effect on configuration. So here we see two processes trying to communicate, and process going to send connection to other session, and that changed the shape a bit. In general this can be a little more complicated. The messages can be pairs of channels or list of channels, so the transformations is a bit more complicated.
Another thing in real system, we have a synchronous semantics that means there is also some interneediate state, so pictures not exactly like this. If you want to see details of that you have to look at the paper.
And so close is the last operation, very simple, you can only do it if your session has ended. And what that does, it just takes away all the connections of the session, and see, can get disconnected and on the other hand, you see the invariant is still preserved.
>> So we wanted to show this language is really more powerful than GV and you may think that's already the case, if you want the binary session you just make one with two participants but that doesn't quite work, because in this multiparty type system the types have these endices indicated we are communicating, and if you translate GV program to this language, you may end up in cases these indices don't match, with that we introduce the redirect operation, which redirect messages for one destination to another, that then allows us to change this into types, and important for modular programming.
And then, in the translation from GV to MPGV we need to insert this into particular places.
So... you may not know this, but the multiparty session type literature has problems, so here is a quote from David CastroPerezPLDI21. I think they were the first to mechanize anything about multiparty session types.
So they say: Unfortunately the more complicated the behavior is the more error prone the theory becomes the literature reveals broken proofs of subject reduction for several MPST systems. And flaw of decidability of subtyping for A synchronous MPST and all of which are caused by incorrect understanding of the A synchronous behavior of types.
So that's why we mechanize into Coq. So it's the language definition is about 500 lines, the proofs are about 10,000 lines. And this works within a small step asynchronous semantics, with treads and buffers.
So the simple theorem is safety nets as a truss don't get stuck except don't receive that love freedom says that globally, even received don't get stuck on each other. And we have leaked freedom, which says messages don't get left behind. Another problem which dot actually occur in practice is that you may not be mechanizing.
And so its... and the statement relies on some accelerate definitions, which are about 100 lines of code. O how do we know that this theorem actually said something non trivial.
So we think that you should always proven easy to understand corollary. Which would be, you know for sure saying something nontrivial, but can immediately recognize, if you prove this you have really proved something, in our case prove global progress, if you start with program, and steps to configuration, either configuration is empty or can step again, this is not a very powerful theorem, for example, if you have any threat just in the loop, this theoriom holds, but would be impossible to prove this theorem by accident, and can be stated in one line, and requires no auxiliary definitions, and sanity check on data freedom statement, and yeah, I think this is very important.
And so what's in the paper, so we have the full language definition, of semantics, asynchronous semantics, we have choice we have recursive types because of session types which can also be mutually recursive, linear types and unrestricted types. Which you can freely copycopyand discard. We have most party consistency and global types, if you know what that is.
We have dead lock freedom proof and pictures, formal details with separation logic, and encoding Giulio and MPGV, and all the theorems mechanized in Cog.
So that's my talk.
Thank you for listening.