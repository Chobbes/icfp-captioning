>> So I'm going to talk about Ineas. Which is verification for work safe rust programs.
Bit of context first, rust, low level memory safe language.
Good way to have understanding rust is compare to C.
So for instance in C, you can write the following function, takes Boolean, and depending on the Val of the Boolean, returns one of the two pointers, and then can use by giving pointers to the variables, X and Y, retrieve point of Z and use to in place of dates. We see the type system doesn't give any guarantees by the pointers you manipulate from here. You don't know how they are, and this is also true when you... for instance, with X and Y. This can relate to a lot of bugs in relation to memory management.
In rust... the true function is the same that instead of using pointers use burrows,. So...
here X and Y, unnecessarily...... nondangling, exclusive access, they cannot against each other. There's also another important thing which is that we have enough time here, which appears in which is you analyze the different burrows, and out put, and give constraint... and if we caliberos, And because it has the same implement burros Z, as long as variable are borrowed, which means they can be accessed.
Because... then you can use for dates like on the left, and of course later retrieve access to X and Y, but when you do you need to evaluate the house. So here the left hand goes to here, and from own words, retrieve access to X and Y, the the fact you use correctly, lust...
checker. And this type of system was designed to initially provide memory safety, but also provides a lot more. In particular, in a sense you don't have any liasing in program. So what happens here, the important... that you can't choose X and Z at the same time.
So as long as Z is valid, and retrieve access to X and Y, and that moment on ward, Z is invalid.
So this gives you very STRAURD management of memory. So literal question from there.
Can we leverage this very structured and disciplined management of memory to simplify memory reasoning, in the context of program verification, particularly interesting in the con TESHGS that you do have program verification, reasoning and memory is... difficult problem. And used more and more for programming. And so this provides opportunity for scaling more on the preample will Iification, and question of leveraging, and is not new, and explored a lot in the past few years, and led to quite a few frameworks, interesting that most of the frameworks SPLAP one point in the design space.
Typically, require the user to take the risk programs.
Typically conditions and use those programs to generate formula, by rev languaging research centre, and yes, everything is fine, I don't FRM that I get proofs, you direct, will date practice ams. And...
finishsting proofs by which the programs, and then do the proofs in one group, and delivered your huge But there are other points in the design space that you may want to explore. So for example, what about extrinsic proofs by which you have a model of your program. And then on the sign your rights and privileges, and this gives you more modularity And what are they having less automation, but the principal, automation and more direction.
And this is the direction is decided to explore a new framework, which, is called Aeneas. Rust program, leverages the rest suggesting to translate it to a pure executable model, which can then be extracted to value and then you can write and problem us this model. The important point is that because it's pure. You don't have when you stay in progress to reason about memory energetic, and you can instead focus on the functionality of your program.
So what does this look like.
This is similar to he is one previous project, and trying to have have... so, what are these formally look like. Let's go back to the truth example, we can do the translation step by step, and the beginning is quite simple, so for the beginning, what we fleed to say, is we introduceintroduce ... need to say, we introduce, X y&z for those here We use a purified version of our choose function, which is typically choose but we remove burrows and comes being flexible. By using this date, we modify X, as I said previously, as long as length of leaves we don't access X and Y, and don't have to take into the account this date yet. And, What we have to say is that z gives us access to some value. And at this moment, this value gets ability is 2.
And then comes the interesting point. Here, we get access back to x and y which entity lifetime alpha And at this moment when you observe the fact that we have made modifications. But, so, at this moment, we retrieve access to x and y, we can observe those modifications.
It's important at this point we have to propagate the changes that have been performed. We have to say, we get new values, for X and Y, now what are those new Vals. It's actually quite simple. As the Boolean head it's true. And so X. And why is left unchanged. So the new Val for why Y, is so the Bool case is true. If it was true, we have... and X would be unchanged and Y would be updated. So if we want to be more precise we can write the following. And here we see something with the case. When we could choose we write z. And so we did some forward computation. And then when we left the left there. We go the other way, that we loan the function, we do backward computation. Now, if we write things a bit, get the following.
When we call the truce function in the transmission we use a choose the forward function. We see the same functions before, which is the purefied version.
And then when the last time we need to propagate the changes back to x and y, and record to choose backward function, back into the environment.
Now those two work a bit like lenses actually.
And this is the whole idea around translation, when we have a translation, we bring to one ford function, and, and we use as changes to impact back into the into the environment, Now something interesting about this permutation is that it is actually very modular. The reason is that in order to generate this snippet of code.
You don't need to know the body of truth here need to know is signature. And you can see that from the fact that the and the truth backward functions can be derived by looking at only to be more precise, what should forward, we need to do is look at the inputs and the outputs, and purify them, typically by removing the boroughs, so it comes up backward. We said the same inputs, forward, because we need them for example for the control flow and we need to remember it for x and y. Then we look at the output and see what happens is that for every borough that return time alpha, we need to back. So we need to provide these you backwards. So here we take additional input.
And returns Vals for loans we received. And so we have...
emotional translation. And today, useful to handle external dependencies or features we don't support yet. Just have to treat them as opaque declarations. And we believe with YIGSthis version features and traits and function pointers. Now, this gives us the following framework. On the left we had thethe Rust compiler. And we wrote the plugin to retrieve the output of this compiler and convert it to an AC we call the role of a broken plus, and the reason why we dothat is the Rust compiler, is extremely easy to use malarkey So the reason behind this compiler plugin called Calico is to provide an easy to use interface to generate a simple ASD that can then its own use. And then comes the transmission mechanism itself. Yes, which customer CSD and generates a pure model, which can then be extracted.
As of today we have one backend for instance. But we also are also working on backend for God and artful, and of course we're interested in having more back ends, transaction works through is symbolic execution. We actually have we need to translate your function. We need to know every point in the function. Who borrows what from home. And because of that have to check the borrowers are quietly used. Which means don't have to trust the borrow checker. Also along the way to getting this to work, we have, we had to come up with some operational semantics forest, and this is no vehicle, in particular for explorer mechanism. And this is another contribution of this paper.
Has quite a few limitations and only support safest, only use the leverage, we belief it shall not. And don't have loops, this is on going work, and I don't have interparticular aty. Why we don't have national goals, and it's important to know in the context of the plantation.
So engineering point of view.
The pluggin, whose goal is provide once again, user interface compiler. Should be completely independent from Aeneases. And also supports unsafe good, and should be reasonable for the projects, and we have used for framework, so we can also handle... finally, when the code is publicly available on GitHub. Thank you for your attention.