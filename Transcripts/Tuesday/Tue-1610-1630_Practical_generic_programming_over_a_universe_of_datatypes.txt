I'm going to give a talk about programming. It will sound very familiar to you.
There are two key words in this title that are very important, one is practical, so I am going to sflan what we mean by 'practical skwoets, and try to convince you that our -- explain what we mean by 'prakal', and the other one is native data types. Another one word that is missing is 'safe". What we focus on in this work is to have a way to define data construction safely that is once it works you know it will always work regardless of which data type you use. So I assume by now most know what data type generic programming is. It is the art of defining constructions that can be applied to any data type using a simple implementation.
The benefits are quickly visible, so you have codification and also you can get consistent behaviour by having a having a single implementation. One of the most common example in circles is the use of deriving ... most people that use it knows the benefits of deriving so many constructions for free, essentially, as soon as you introduce your own. It can be very simple, like the ability to debug, print values of the data type, but it can get intricate and especially with generics.
You are able to derive for free many quite involved constructions. So a fair question would be that is interesting in Haskell, but why would you need this in Agda? So a simple answer would be they are programmings in their own rights. There are actually many generated constructions that are very interesting and useful when you're trying to prove things of data types, so most of you probably know that you always have a principles that come with any data types, and there are actually other constructions that exist in the same kind of way, and some of them I introduced in a paper called a few constructions on stricters.
In this paper it explains that there is a recipe for defining them for any type, like there is a systematic way to define them, and then it is only a matter of having a system to derive them ally. Another common example is decidedable equality. It is way more interesting to get to witness two values are equal or proof that they are distinct. Of course, there are other examplesexamples. I've shown a bit of an example here. It is an index type. It is usual to want to [indistinct] you kind of would like to long wish to always give this to you. That is assuming some equality on A and ... by A.
Likewise, you can expect to have this principle and in cook you do. When you define, you will get this principal for free. So what is a solution? If your language doesn't give you any deriving primitive, there are two approaches. As you just saw of courses there is a thing called elaboration. A fair comparison would be Haskell. You are able to manipulate in syntax and under the conditions you can define almost anything. It is a very powerful mechanism. It tells you to produce definitions that look just like if they were ... but it is hard to implement using code. It is very diverse.
You have to be careful about the transformation you do on terms.
You have to use the brandishes and it is usually the hard to ensure that you don't do any mistakes. It is hard to guarantee that you have certain properties because you can only know if you fail once you institute it for a given prototype. It is hard. The other one approach is to use what is called universe of descriptions.
The idea is you internalise, you make explicit what it is to be a data type and you work inside a coding. You explain what is the description. You interpret the description as a shape and then you take the six points and you end up with a type, an Agda type that behaves pretty much like a native data type that you're trying to describe. When you use this kind of coding, it is very easy to define constructions.
You essentially quantify overall the descriptions. Generally constructions are regular Agda functions and there is no trick to it. Once it is implemented, you know it will be correct, but, of course, you are putting properties and not native data types. As soon as you want to derive generic properties, you need to work with this coding.
It is not very practical. So our goal is to find how to bring this kind of universal descriptions and the benefits of it closer to what native data types are so we are able to define generic constructions that do not operate on new but on nature data types and it is correct by definition. With this in mind we wanted to build a library. We wanted to provide safe primitives to implement constructions and, of course, we wanted to implement constructions to demonstrate that this is a practical approach for regular Agda users.
We also had pretty strict constraints. We wanted to avoid using reflection at all, to define generic constructions, and so this was a challenge that we had to face. We also wanted to be safe, to be in the safe fragment of Agda. This means that we really had to convince Agda that they were terminating, which is an issue that you have to deal with when you work with these codings. Also we wanted to have user friendly construction that is generally constructions that have the proper types that you would expect if you had written it by manned, and we wanted to have them to compute and reduce as you would expect them to -- written it by hand.
I'm glad to say that we succeeded. We have a library.
Assuming that you install it, you have to derive an encoding of data types you want to have constructions over. So this is a macro. This is the only place where you actually use reflection and then once you have this encoding, you can use all the constructions available in library. So the first one we implemented is, of course, the generation conduction principle.
I have to confess that maybe the name isn't quite what it should be. We are not generating code.
It is a regular Agda function that happens to take an encoding as an argument and will come Putin as the appropriate type once it gets its first fragment.
Applying to the description of natural numbers you will have a function which is precisely the eliminator that you would expect, applied to other descriptions you end up with a very systemic and actually useful type and all this means it is a regular function, and very important things that we wanted to enforce was proper computational behaviour. We see here that we defined the numbers, and we see it is able to make progress. If you see the S definition, so N is a free variable and if we apply add it is possible to move it out of the addition. This is very important because it allows you to actually use the constructions inside proofs, and there have been attempts to do this kind of attempts in Agda and it was computational always the missing part. I want to emphasize that here I have written the types explicit live, but you don't have to do it and you don't actually have to make - every time you want to use, you just have to give it a description. I think it is pretty useful. We implemented decidedable equality. We have a derived intervention. If you give it a description of natural numbers, you end up with what you expect. It is easy to fetch the appropriate depen residencies, so, for example, like on vectors, it will ask for equality on some parameter.
Another construction that is very useful is proof of jointness of constructors. You always have the properties that distant constructors are unequal, about you have to prove it yourself. This involves as many functions as you have pairs of constructors and here with a single implementation, no done fusion, we're able to prove all the properties. You see the two first definitions show that suc is different to 0. We are able to prove that suc is objective using the same implementation.
I'm just going to give some idea of the technical challenges that we have to face to implement. We in to find a very precise encoding of telescopes for what independent cease are. We ended up with the scope with recursion. We also had to enforce data type descriptions.
Then the question was how to bridge a gap between this encoding of data types and actual Agda native data types.
What we quickly realised was that you should avoid taking the six points and implementing construction on that. You see what was a constructor what was used and the arguments. What we derive is only shallow conversion functions that is for some value of type A we're able to know where it came from and we are able to do the reverse.
Another variant was accessibility predicate. If you are unable to split the value into its arguments and constructor, there is no relationship between the arguments that you get and the initial value and so Agda will not allow you to recurs this many times and so you have to find a way to convince Agda to do this kind of stuff. So it was to introduce accessibility predicate that would derive coding and so it guarantees that any value is well-founded. Then we had to implement the construction that I just showed you, again with no reflection and that are caught by the definition. This is the only bit that I'm really sure. This is the content of the record. It only contains a description, conversion functions and access inlity predicate. That's all that was needed to implement all the skrungs that I showcase. So, yeah, whatever is available and it mostly worked and I think it is a good example or at least it proves that user friendliness is not exclusively safe, but you can have safe and generic that still are useable, but there are, of course, more work to do.
We don't support ... nested types, induction-recursion, mutually defined data types. We are looking for a fine year encoding. Our test scope at the given position gives access to all values in the test scope, and I actually want something finer E we are happy that there is other work being done, so it is very interesting and we are very much looking forward to find how to merge the work that we did to maybe find a good library out of the two. So, yeah, Thank you for listening.