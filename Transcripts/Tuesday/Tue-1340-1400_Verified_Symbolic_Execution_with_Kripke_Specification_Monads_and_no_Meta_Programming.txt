>> Thank you for the introduction. And thanks for attending my talk. So this is the program verification session, and that's also the application of symbolic execution than I have in mind.
So the general setting maybe something like this given an implementation , we want to derive, if it's conforming to specification. For instance giving pre, postconditions. If you are serious about it might want to do somewhat formally, and if you are very serious might want to mechanize it in approve system. FT the general approach, or the common approach is something like this we embed the syntax of our language, deeply in the proof assistant, for assurance we use shallow embedding, and rep sent assertions somehow using the proposition of the system. We then use facilities it gives us for instance to use simplification, and reasoning root of logic and system will check each step is actually sound, so that means program verifying is essentially metaprogram, and each run of the metaprogram is verified to be sound individually.
What if we actually use the deep embedding for assertions at well, instead of implementing a metaprogram, we implement a normal program into the proven system.
And so that means that well, with the goal of also proving soundness, but proving soundness once and for all for every run, so this is what the talk is about. It's systematic approach of how to use symbolic execution to build such program clarifiers, semi automatic, in general might be in a case it's undecidable, and need some... we need some help from user to actually perform verifications.
And other contribution I also want to talk briefly about, Katamaran, this is program verifying that we're building specific language for instruction sets. The structure we're proposing is as follows:
Essentially build the system twice, once you implement a symbolic executer, and implement shallow executer with the same structure, and same behavior, and using shallow embedding, and we want to make this proof, so we want to reduce the proof of the symbolic executer for the shallow executer, and make as systemic and hopefully pain-free as possible.
Once you are in the shallow world you are in familiar waters, and you can use the normal techniques for instance, to show that this yields derivatis on in the programme logic, and Katamaran specifically specify the, axiomatic program logic, we proveexecute a sound with respect to that one, we instantiated the iris framework with the operational semantics, language, and we proved that the axioms of the program of the code in the iris model. So this talk talk with colour codes, will all be symbolic executions and for the shallow one, and use capitalized and noncapitalize letters, so you don't lose orientation, let's start with shallow execution first. Preand post condition. Bit clunky, and want to change the setting a bit. So in general want to talk about verification conditions which are just formula sufficient to actually prove derivation in the program logic.
Most SPIKly want to talk about -- precondition one way to implement verification condition traditional naive way. And we look at team of weakest precon operator for instance, in statement of imperative language, it maps out puts to predicates. Maps postcondition to condition, and weakest precondition. In a proof system, we might actually want to take predicates to be just mappings to the propositional types, If we use this definitions we can SHUFal the type around a bit and mapping the input to the cop out put. And, continuation monad with answer type prop can result type output. You might have seen this already. So in the past there have been flurry of research papers exercising such monad, and promising to give them to us for free for all and forever. And the idea is we use these monad to write your specifications in. And if you implement the computations specific monad. You can derive a verification condition generator and you can use that to reason about monadic code. So that's very common in thesystem where lots of authors work on.
So what if our monad code is monk interpreter, just what we did previously, that means this interpreter basically implements the is he Manitobasive object language as weakest predicate transformer and use that to implement a verification condition generator.
If you want to add side effects to your interpreter that's fine, just use monad transformers, and it will give you transformed continuation monad that has the right shape of postconditions.
Okay let's do this.
So let's maybe interpret an expression language, and derive something that computes a Val in such a monad. So if you look at if case. We want to evaluate the condition first and depending if it's true or false use one of the branches, so here implementing the object level if using the metaLEBL. So using pattern matching and have to think a little bit ahead, and want to... THAET that one do in this case.
And so somehow represent pattern matches also explicity, or go traditionally rout, and avoid pattern matches and translate them away. So the rules reasoning route so we could preconditions, which use the logical connectives of your social language to implement these. Can abstract away from these a bit. These features if we really want to work at the level of abstraction of monad corNOND to actually angelic, and demonic nondeterminismm features.
So we can implement invalid non determinism with the underlying exist, quantify your demonic with a formal binary non determinism using dysfunctional in conjunction, and then we can also implement guards, for instance. And can assume certain proposition for the remainder of execution path.
So if we use this to... and seems something we also can implement in symbolic setting.
Just note here the control flow constraints that assumed are qualities that will generally be the case for almost every language.
So look at symbolic executer, talk about what we want to represent first, so the propositions that away want to deeply embed, instead of shallow embedded propositions.
So symbolic values. We using existential and universal quantification, we have to represent them somehow we are defining a set of logic variables. And then we also defining a set of symbolic values are symbolic expressions which have all the formats of values, values but also I have a new case for the symbolic variable. The control for constraint specifically as I said, our equations between symbolic expressions, but we can also add user defined theories that come from the key impose conditions, which are done in a user defined subset which really can be anything. For symbolic proposition, we have to implement something that actually allows, angelic and demonic non determinism features and provide version of logical connective that we use constructors, and so monad uses symbolic representation as an answer type and implement weakest preconditions. And then, generate using that. And those are challenges, and so now all sudden have to deal with variable binds ourselves and ensure all the propositions we generate are well spoke and formed and well typed. And we have to reason about this, right?
Fortunately we already have the machinery to actually do that.
This is very similar to the case of dynamic allocation of memory.
For which we use possible word semantics, and can also use in this case to reason about logic variables, and another challenge that is coming exponential explosion because of more or less naive implementation. So what do real listic systems do.
They try to do an allowed to avoid explosion of execution paths.
And so might want to for instance, detect when assertion is actually unsatisfiable. So for instance, if false = true.
In this case, in the second component hereof the con junction we have whole subtree which we would need to compute which of course we will just throw away in the end. So when we already detect this unsatisfiable constraint, we want to detect and put a false there. Not only do that locally, but keep track of all the past control flows constraints seen and maybe restrictions and constraints that come from the precondition, from postcondition. And how can we incorporate that in our reasoning. And quick example, where we pattern much on same variable twice, and execution branches is of course impossible. Talking about symbolic execution without a trace of the tree.
So if not here in the in the T con corresponds to a control flow point in the program. And as you can see in the middle, there is the point, where x, and left in the other one. Sorry, left and right at the same time which is inconsistent.
So people in symbolic execution, not only represent the problem state, but also contextual information, so the control constraints from a note to root of the tree and all the logic variables that have been introduced.
So what if we just took these constraints and put them in our worlds as well. So use possible world semantics to use the binding and keeping track of logic variables, and also use to manage our constraints, so define, like that. And accessibility means we can add more constraints and more variables, but never take anything out.
So, how do we actually program this?
We can... so in order to do that we need to keep somehow track of these worlds.
So it would be best if we could abstract away from this. And show you how we describer define some of the... that will more or less hide bit of the details, but essentially, will keep passing worlds to... and dealing with them explicitly, and further more, we will not only pass them in implementation, we also index everything that comes after by the world. So we work with families of World Index types. And we do that, to make sure that, well, all of our propositions in all of our symbolic values are well scoped and well typed. Which other people have done before, and also make sure the constraints, are consistently moved. And can't move Val generate ated, under a certain constraint for instance, with sibling sibling in the execution path. Or to the parent in the execution path in the execution, sorry, because that would be unsound. So we can define form of function types, so world W. This is just function of corresponding instances of family members, so we go here, monoo logic rout.
And define explicit box operator, and make sure type or specifically functions monoo tone. Which we do by just universal quantifying, accessible world.
So basically what we want, what we have seen here previously, we have 3 leafs or 3 subtrees, in which we use to post condition.
And these are in different worlds, but at the very beginning of the top of this.
The condition tree, the postcondition was in single world. So we define the predicate, and we show post conditions are actually monoo tone. So for the programming, we can define all of the abstractions so assume, assume cards and so on. Using these primitives, and world passing here, accessibility... with us, and otherwise the progress really has same structure. So pruning states. Sometimes we can do more, having access to the world. So you might take the current world. And formula that we are sorting and running a silver, which will tell us, the formula is valid, or ininconsistent with the constraints we seen previously, so could get the execution this point.
And so actually skip this. The keyword here is define Kripke index logical relation. That actually links the implementation sounds very much like an equivalence proof. T's sort of an equivalence, you want to show that the symbolic computation is actually stronger than than the shallow one . For implementation Katamaran, as I previously said it's separate from the clarifier implemented in it's not fully automatic and semi automatic. And we also have some escape hatches so we not, don't do everything using Katamaran, mostly really everything on boiling plate.
Where you just want to apply very basic rules very basic and so on. For the very hard an interest in cases, these we'd actually do manually. In, in the iris framework. So semi automatic. We allow the user to provide some automation himself, so whole system is parametrized by user theory, and able they could reasonable steps, those...
residual proof obligations.
>> Just as example, separation logic, a case which has been implemented in some other systems, keep an f systems or Raynolds.
Heap allocated linkless so mutable data structures. So we've tested that the verification times in via C in the separation of recommendations and bedrock, which you forward you will find the numbers only in the paper.
So here are the results. As you can see for the verification times Katamaran is 1 to 2 orders magnitude faster. Which is consistent kind of like with other observations or computational reflection speeds up proofs and with this magnitude. Means that we couldn't actually find implementation in the codebase of these also lemmas, hat we have to prove consensus folding and unfolding of the linked list, .
>> So in the paper you will find more information about symbolic separation logic about adding debug information and about case study, which is a bit larger. So in conclusion possible semantics reason, about logic variables, and symbolic execution and have program verifier with competitive performance, thank you for attention.